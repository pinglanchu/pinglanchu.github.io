<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python绘制热图</title>
      <link href="/2020/06/09/%E6%96%91%E5%9B%BE/"/>
      <url>/2020/06/09/%E6%96%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要用到python来绘制热图（斑图， 色度图），查阅资料之后发现主要使用matplotlib库中的imshow函数来实现。</p><h1 id="函数参数解析"><a href="#函数参数解析" class="headerlink" title="函数参数解析"></a>函数参数解析</h1><blockquote><p>matplotlib.pyplot.imshow(X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, shape=<deprecated parameter="">, filternorm=1, filterrad=4.0, imlim=<deprecated parameter="">, resample=None, url=None, *, data=None, **kwargs)[source]</deprecated></deprecated></p></blockquote><blockquote><p>X: array-like or PIL image（数组或者是图片）<br>cmap: str or Colormap(颜色映射)<br>norm: Normalize(标准化到（0， 1）区间)<br>aspect: {‘equal’, ‘auto’} or float(控制轴的纵横比)<br>interpolation: str(插值方法)，可选为( ‘none’, ‘antialiased’, ‘nearest’, ‘bilinear’, ‘bicubic’, ‘spline16’, ‘spline36’, ‘hanning’, ‘hamming’, ‘hermite’, ‘kaiser’, ‘quadric’, ‘catrom’, ‘gaussian’, ‘bessel’, ‘mitchell’, ‘sinc’, ‘lanczos’.)<br>剩下的具体参数解释可参考<a href="https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.imshow.html" target="_blank" rel="noopener">文档解释</a></p></blockquote><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>使用nearest插值方法</strong><br>example 1.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">plt.imshow(arr)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="http://q96n545no.bkt.clouddn.com/FpovNmkYV1TTeoLladUAAuXK5qyp" alt=""></p><p>example 2.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">plt.imshow(X) </span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="http://q96n545no.bkt.clouddn.com/Ft8vM4tRORXbTJMdyWj756eZrcu1" alt=""></p><p>example 3.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mean = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">10000</span>).T</span><br><span class="line"></span><br><span class="line">hist, xedges, yedges = np.histogram2d(x,y)</span><br><span class="line">X,Y = np.meshgrid(xedges,yedges)</span><br><span class="line">plt.imshow(hist, interpolation=<span class="string">'nearest'</span>,cmap=<span class="string">'rainbow'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="http://q96n545no.bkt.clouddn.com/FnP2tMpzO-HUJKwGFAYVFEARR6co" alt=""></p><p><strong>使用bilinear插值法</strong>(当然可选插值方法还有很多)<br>example 1. </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">plt.imshow(arr, interpolation=<span class="string">'bilinear'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="http://q96n545no.bkt.clouddn.com/FoC6jZwTBWBNoktydUsRVGB6eCUB" alt=""></p><p>example 2.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">plt.imshow(X, interpolation=<span class="string">'bilinear'</span>) </span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="http://q96n545no.bkt.clouddn.com/ForhUjY6iVTaT752LMK1ERsLYE00" alt=""></p><p>example 3.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mean = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">10000</span>).T</span><br><span class="line"></span><br><span class="line">hist, xedges, yedges = np.histogram2d(x,y)</span><br><span class="line">X,Y = np.meshgrid(xedges,yedges)</span><br><span class="line">plt.imshow(hist, interpolation=<span class="string">'bilinear'</span>,cmap=<span class="string">'rainbow'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="http://q96n545no.bkt.clouddn.com/Fr6fTE4sKtciMDUwdzPwwvbRbx2F" alt=""></p><p>可以对比使用或者不使用插值方法时生成图片之间的区别。以上是比较简单的示例，例如颜色的渐变，数值的标准化等都没有涉及到，需用用到时可详细参看<a href="https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.imshow.html" target="_blank" rel="noopener">文档解释</a></p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>针对上面两个example 3. 我们也可以使用<code>hist2d</code>函数(当然还有其他的实现，例如<code>pcolor</code>,<code>matshow</code>函数等)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mean = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">10000</span>).T</span><br><span class="line">plt.hist2d(x, y, bins=<span class="number">50</span>, cmap=<span class="string">'coolwarm'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="http://q96n545no.bkt.clouddn.com/FpzJ8P8BkmAUMGvi6OJd7ZOWwtvv" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>python中生成热图的主要方法为imshow()函数，我们看到同样还有很多其他的方法可以实现，他们可以满足不同的画图需求，本文中涉及的函数主要是<code>matplotlib</code>库中的，同样在<code>seaborn</code>中也有热图函数，比如<code>heatmap</code>，本文中介绍的热图函数已经能够满足大多数时候的需求。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python, matplotlib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热图, 斑图, 色度图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成对抗网络（一）</title>
      <link href="/2020/05/18/GAN(%E4%B8%80)/"/>
      <url>/2020/05/18/GAN(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2014年，Ian Goodfellow等人提出一种全新神经网络训练模型–生成对抗模型(Generative Adversarial Network,GAN)。GAN是近年来最火热的无监督学习算法，在此基础上，许多研究者对其不断进行改进，衍生出很多相应的算法，也逐渐将其应用到半监督和有监督学习中。该系列博客主要记录从GAN的理论推导，编程实现和将GAN应用到半监督学习中。这第一篇文章就先将GAN的理论知识和实现简单介绍下。</p><a id="more"></a><h1 id="GAN理论推导"><a href="#GAN理论推导" class="headerlink" title="GAN理论推导"></a>GAN理论推导</h1><p><img src="http://q96n545no.bkt.clouddn.com/Fl6xdArNqoypHvyOAER2DtWCf4c6" alt="原文abstract截图"><br>首先，需要知道的是生成对抗网络的设计是为了estimating generative model，而”adversarial process”是为了完成这一任务的辅助手段。<a href="https://arxiv.org/abs/1406.2661" target="_blank" rel="noopener">原论文</a>摘要中对GAN的设计思想、大致的训练过程都做了很好的说明。下面就好好学习学习GAN的具体理论部分。</p><h2 id="一些概念和约定"><a href="#一些概念和约定" class="headerlink" title="一些概念和约定"></a>一些概念和约定</h2><p>生成对抗网络主要又两个重要的部分组成：</p><ul><li>生成器（Generator):通过不断学习，生成与真实数据相仿的“假数据”，其目标是要成功“欺骗”鉴别器（Discriminator）</li><li>鉴别器（Discriminator）:尽可能将真实数据与Generator生成的“假数据”区分开来。</li></ul><p>生成器与鉴别器相辅相成，两者之间不断对抗的过程，也是二者之间不断学习的过程。结束对抗过程之后，理想情况是Generator能够生成与真实数据分布高度吻合的数据，而Discriminator已经完全不能区分出真实数据与“假数据”。因此，在原文中，作者也提到了”D equal to $\dfrac{1}{2}$ everywhere”。</p><ul><li>$p_g$:Generator通过真实数据$x$生成的分布</li><li>$p_{data}$:真实数据分布</li></ul><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>首先直接引入GAN的目标函数，然后我们再对其进行简单的说明，<br>\begin{equation}<br>\min_{G}\max_{D}V(D,G)=\mathop{\mathbb{E}}\limits_{x\sim p_{data}(x)}[\log D(x)]+\mathop{\mathbb{E}}\limits_{z\sim p_z(z)}[\log(1-D(G(z)))].<br>\end{equation}</p><p>其中，$p_z(z)$是预先定义好的噪声分布，$G(z;\theta_g)$是一个参数为$\theta_g$的可微多层感知器，$D(x;\theta_d)$也是一个多层感知器，其输出为一个标量，$D(x)$表示了$x$来自真实数据而不是$p_g$的概率。</p><p>通过训练$D$，最大化概率区分数据来自$p_{data}$还是$p_g$(显然地，$p_{data}$和$p_g$中的数据都应该进入$D$中进行鉴别)，同时训练$G$来最小化$\log(1-D(G(z)))$</p><p><strong>注：</strong>至于该目标函数是怎么来的，还没有看到一个比较认可的说法。要再好好查查！</p><h3 id="训练策略"><a href="#训练策略" class="headerlink" title="训练策略"></a>训练策略</h3><p><img src="http://q96n545no.bkt.clouddn.com/FlI7r4tybeAoLXD2nsjesfWQ4VTs" alt=""><br>Figure 1可得好好看明白，因为它描述了GAN的一个训练过程。<br>下面给出GAN算法<br><img src="http://q96n545no.bkt.clouddn.com/FmfEfocKAQRRR1ZBrb8xjkQY-u50" alt=""></p><h2 id="证明目标函数收敛"><a href="#证明目标函数收敛" class="headerlink" title="证明目标函数收敛"></a>证明目标函数收敛</h2><p>此部分需要证明GAN中的目标函数是收敛的，即是可以达到最优解的。为什么要证明目标函数是收敛的？因为该目标函数最大最小优化问题，可能不存在最优解，故需要证明是收敛的。</p><p>先证明存在最有鉴别器$D$,</p><p>知道<br>\begin{equation}<br>V(D,G)=\int_x [p_{data}(x)\log D(x)+p_g(x)\log(1-D(x))]dx<br>\end{equation}</p><p>现在，先考虑$\forall a， b$, $a\log x+b\log(1-x)$，有最大值当$x=\dfrac{a}{a+b}$时。再回到公式（2），$V(D,G)$也有最大值存在，当$D=D_G^*=\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)}$，我们知道最优鉴别器应该处处$D(x)=\dfrac{1}{2}$，因此$p_{data}(x)=p_g(x)$时，鉴别器$D$达到最优。</p><p>接下来就要证明当且仅当$p_{data}(x)=p_g(x)$时，$C(G)=\max V(D,G)$达到最小值。</p><p>$\stackrel{充分性}{\Longrightarrow}$   当$p_{data}(x)=p_g(x)$时，<br>\begin{equation}<br>\begin{split}<br>C(G)&amp;=\int_x p_{data}(x)\log(\dfrac{1}{2})+p_{g}(x)\log(\dfrac{1}{2})dx\<br>&amp;=\log(\dfrac{1}{2})(1+1)\<br>&amp;=-\log 4<br>\end{split}<br>\end{equation}</p><p>$\stackrel{必要性}{\Longleftarrow}$</p><p>$$<br>\begin{split}<br>C(G)&amp;=&amp;\int_x p_{data}(x)\log\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)}+p_g(x)\log\dfrac{p_{g}(x)}{p_{data}(x)+p_g(x)}\\<br>&amp;=&amp;\int_x(\log2-\log2)p_{data}(x)+p_{data}(x)\log\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)}\\<br>&amp;&amp;+(\log2-\log2)p_g(x)+p_{g}(x)\log\dfrac{p_{g}(x)}{p_{data}(x)+p_g(x)}dx\\<br>&amp;=&amp;-\log 2\int_x(p_{data}(x)+p_g(x))dx+\int_x p_{data}(x)(\log 2+\log\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)})dx\\<br>&amp;&amp;+\int_xp_g(x)(\log2+\log(1-\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)}))dx\\<br>&amp;=&amp;-\log4+\int_xp_{data}(x)\log\dfrac{p_{data}(x)}{(p_{data}(x)+p_g(x))/2}dx\\<br>&amp;&amp;+\int_xp_g(x)\log\dfrac{p_g(x)}{(p_{data}(x)+p_g(x))/2}dx\\<br>&amp;=&amp;-\log4+KL(p_{data}||\dfrac{p_{data}(x)+p_g(x)}{2})+KL(p_g||\dfrac{p_{data}(x)+p_g(x)}{2})\\<br>&amp;=&amp;-\log4+2JSD(p_{data}(x)||p_g(x))\geq -\log 4<br>\end{split}<br>$$</p><p>当且仅当$p_{data}(x)=p_g(x)$时，取最小值$-\log 4$，证毕。</p><h1 id="GAN实现（PyTorch）"><a href="#GAN实现（PyTorch）" class="headerlink" title="GAN实现（PyTorch）"></a>GAN实现（PyTorch）</h1><p>到目前为止，将GAN的整个理论部分过了一遍。下面开始用PyTorch来简单实现下GAN。<br>首先导入需要的库，然后构造生成器和鉴别器</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> matplotlib.mlab <span class="keyword">as</span> mlab</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, output_size, f)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.map1 = nn.Linear(input_size, hidden_size)</span><br><span class="line">        self.map2 = nn.Linear(hidden_size, hidden_size)</span><br><span class="line">        self.map3 = nn.Linear(hidden_size, output_size)</span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.map1(x)</span><br><span class="line">        x = self.f(x)</span><br><span class="line">        x = self.map2(x)</span><br><span class="line">        x = self.f(x)</span><br><span class="line">        x = self.map3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, output_size, f)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.map1 = nn.Linear(input_size, hidden_size)</span><br><span class="line">        self.map2 = nn.Linear(hidden_size, hidden_size)</span><br><span class="line">        self.map3 = nn.Linear(hidden_size, output_size)</span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.f(self.map1(x))</span><br><span class="line">        x = self.f(self.map2(x))</span><br><span class="line">        <span class="keyword">return</span> self.f(self.map3(x))</span><br></pre></td></tr></tbody></table></figure><p>下面对输入数据做简单处理</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(name, preprocess, d_input_func) = (<span class="string">"Only 4 moments"</span>, <span class="keyword">lambda</span> data: get_moments(data), <span class="keyword">lambda</span> x: <span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(v)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> v.data.storage().tolist()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [np.mean(d), np.std(d)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_moments</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="comment"># Return the first 4 moments of the data provided</span></span><br><span class="line">    mean = torch.mean(d)</span><br><span class="line">    diffs = d - mean</span><br><span class="line">    var = torch.mean(torch.pow(diffs, <span class="number">2.0</span>))</span><br><span class="line">    std = torch.pow(var, <span class="number">0.5</span>)</span><br><span class="line">    zscores = diffs / std</span><br><span class="line">    skews = torch.mean(torch.pow(zscores, <span class="number">3.0</span>)) <span class="comment"># 计算偏度</span></span><br><span class="line">    kurtoses = torch.mean(torch.pow(zscores, <span class="number">4.0</span>)) - <span class="number">3.0</span>  <span class="comment"># 计算峰度 excess kurtosis, should be 0 for Gaussian</span></span><br><span class="line">    final = torch.cat((mean.reshape(<span class="number">1</span>,), std.reshape(<span class="number">1</span>,), skews.reshape(<span class="number">1</span>,), kurtoses.reshape(<span class="number">1</span>,)))</span><br><span class="line">    <span class="keyword">return</span> final</span><br></pre></td></tr></tbody></table></figure><p>接下来设置超参数并开始训练GAN</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">data_mean = <span class="number">4</span></span><br><span class="line">data_stddev = <span class="number">1.25</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Model parameters</span></span><br><span class="line">    g_input_size = <span class="number">1</span>      <span class="comment"># Random noise dimension coming into generator, per output vector</span></span><br><span class="line">    g_hidden_size = <span class="number">5</span>     <span class="comment"># Generator complexity</span></span><br><span class="line">    g_output_size = <span class="number">1</span>     <span class="comment"># Size of generated output vector</span></span><br><span class="line">    d_input_size = <span class="number">500</span>    <span class="comment"># Minibatch size - cardinality of distributions</span></span><br><span class="line">    d_hidden_size = <span class="number">10</span>    <span class="comment"># Discriminator complexity</span></span><br><span class="line">    d_output_size = <span class="number">1</span>     <span class="comment"># Single dimension for 'real' vs. 'fake' classification</span></span><br><span class="line">    minibatch_size = d_input_size</span><br><span class="line"></span><br><span class="line">    d_learning_rate = <span class="number">1e-3</span></span><br><span class="line">    g_learning_rate = <span class="number">1e-3</span></span><br><span class="line">    sgd_momentum = <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">    num_epochs = <span class="number">2000</span></span><br><span class="line">    print_interval = <span class="number">100</span></span><br><span class="line">    d_steps = <span class="number">20</span></span><br><span class="line">    g_steps = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    dfe, dre, ge = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    d_real_data, d_fake_data, g_fake_data = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    discriminator_activation_function = torch.sigmoid <span class="comment"># 鉴别器激活函数</span></span><br><span class="line">    generator_activation_function = torch.tanh <span class="comment"># 生成器激活函数</span></span><br><span class="line"></span><br><span class="line">    d_sampler = get_distribution_sampler(data_mean, data_stddev)</span><br><span class="line">    gi_sampler = get_generator_input_sampler()</span><br><span class="line">    G = Generator(input_size=g_input_size,</span><br><span class="line">                  hidden_size=g_hidden_size,</span><br><span class="line">                  output_size=g_output_size,</span><br><span class="line">                  f=generator_activation_function)</span><br><span class="line">    D = Discriminator(input_size=d_input_func(d_input_size),</span><br><span class="line">                      hidden_size=d_hidden_size,</span><br><span class="line">                      output_size=d_output_size,</span><br><span class="line">                      f=discriminator_activation_function)</span><br><span class="line">    criterion = nn.BCELoss()  <span class="comment"># Binary cross entropy: http://pytorch.org/docs/nn.html#bceloss</span></span><br><span class="line">    d_optimizer = optim.SGD(D.parameters(), lr=d_learning_rate, momentum=sgd_momentum)</span><br><span class="line">    g_optimizer = optim.SGD(G.parameters(), lr=g_learning_rate, momentum=sgd_momentum)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> d_index <span class="keyword">in</span> range(d_steps):</span><br><span class="line">            <span class="comment"># 1. Train D on real+fake</span></span><br><span class="line">            D.zero_grad()</span><br><span class="line"></span><br><span class="line">            <span class="comment">#  1A: Train D on real</span></span><br><span class="line">            d_real_data = torch.Tensor(d_sampler(d_input_size)) <span class="comment"># 从均值为4，标准差为1.25的正态分布中抽样500个样本作为real data</span></span><br><span class="line">            d_real_decision = D(preprocess(d_real_data)) <span class="comment"># 将该数据的均值，方差，偏度，峰度作为鉴别器输入</span></span><br><span class="line">            d_real_error = criterion(d_real_decision, torch.Tensor(torch.ones([<span class="number">1</span>,<span class="number">1</span>])))  <span class="comment"># ones = true</span></span><br><span class="line">            d_real_error.backward() <span class="comment"># compute/store gradients, but don't change params</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#  1B: Train D on fake</span></span><br><span class="line">            d_gen_input = torch.Tensor(gi_sampler(minibatch_size, g_input_size))</span><br><span class="line">            d_fake_data = G(d_gen_input).detach()  <span class="comment"># detach to avoid training G on these labels</span></span><br><span class="line">            d_fake_decision = D(preprocess(d_fake_data.t()))</span><br><span class="line">            d_fake_error = criterion(d_fake_decision, torch.Tensor(torch.zeros([<span class="number">1</span>,<span class="number">1</span>])))  <span class="comment"># zeros = fake</span></span><br><span class="line">            d_fake_error.backward()</span><br><span class="line">            d_optimizer.step()     <span class="comment"># Only optimizes D's parameters; changes based on stored gradients from backward()</span></span><br><span class="line"></span><br><span class="line">            dre, dfe = extract(d_real_error)[<span class="number">0</span>], extract(d_fake_error)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> g_index <span class="keyword">in</span> range(g_steps):</span><br><span class="line">            <span class="comment"># 2. Train G on D's response (but DO NOT train D on these labels)</span></span><br><span class="line">            G.zero_grad()</span><br><span class="line"></span><br><span class="line">            gen_input = torch.Tensor(gi_sampler(minibatch_size, g_input_size))</span><br><span class="line">            g_fake_data = G(gen_input)</span><br><span class="line">            dg_fake_decision = D(preprocess(g_fake_data.t()))</span><br><span class="line">            g_error = criterion(dg_fake_decision, torch.Tensor(torch.ones([<span class="number">1</span>,<span class="number">1</span>])))  <span class="comment"># Train G to pretend it's genuine</span></span><br><span class="line"></span><br><span class="line">            g_error.backward()</span><br><span class="line">            g_optimizer.step()  <span class="comment"># Only optimizes G's parameters</span></span><br><span class="line">            ge = extract(g_error)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> epoch % print_interval == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Epoch %s: D (%s real_err, %s fake_err) G (%s err); Real Dist (%s),  Fake Dist (%s) "</span> %</span><br><span class="line">                  (epoch, dre, dfe, ge, stats(extract(d_real_data)), stats(extract(d_fake_data))))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Plotting the generated distribution..."</span>)</span><br><span class="line">    values = extract(g_fake_data)</span><br><span class="line">    mu = np.mean(values)</span><br><span class="line">    sigma = np.std(values)</span><br><span class="line">    print(<span class="string">" Values: %s"</span> % (str(values)))</span><br><span class="line">    n, bins, patches = plt.hist(values, bins=<span class="number">100</span>, normed=<span class="number">1</span>)</span><br><span class="line">    y = norm.pdf(bins, mu, sigma)</span><br><span class="line">    plt.plot(bins, y, <span class="string">'r--'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Value'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'probability'</span>)</span><br><span class="line">    plt.title(<span class="string">r'Histogram of Generated Distribution: $\mu={}$, $\sigma={}$'</span>.format(round(mu,<span class="number">2</span>), round(sigma,<span class="number">2</span>)))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train()</span><br></pre></td></tr></tbody></table></figure><p>好，我们来看看最后训练出来的结果<br><img src="http://q96n545no.bkt.clouddn.com/Fqwoici1y6APYM7vvfjJJ5YatVrM" alt=""><br>可以看到，我们预先设置好的正态分布$\mu=4, \sigma=1.25$，通过GAN训练之后，生成器$G$从均匀分布中生成了$\mu=3.9, \sigma=1.24$的正态分布，这已经非常逼近真实分布$p_{data}(x)=N(4, 1.25)$。</p><p>第一篇GAN记录就写到这里，下次学习了将GAN用于半监督学习之后再写。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Deep learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nerual network, PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解python中的装饰器</title>
      <link href="/2020/04/28/python_decorator/"/>
      <url>/2020/04/28/python_decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写过一段时间的python代码或者阅读过python程序的人一定不会陌生“装饰器”，其语法糖为@。今天就来好好看看到底什么是python装饰器，它到底装饰了什么？以及为什么要使用装饰器。</p><h1 id="“装饰器”"><a href="#“装饰器”" class="headerlink" title="“装饰器”"></a>“装饰器”</h1><h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><p>python装饰器是的本质也是函数或者类，它接受另外的函数的作为其逻辑参数，将真正的业务函数包裹在其中。在不影响业务函数执行情况下，对业务函数添加额外的功能。</p><h2 id="为什么要用装饰器"><a href="#为什么要用装饰器" class="headerlink" title="为什么要用装饰器"></a>为什么要用装饰器</h2><p>在前面已经说过，装饰器的作用是在不影响业务函数执行情况下， 对业务函数添加额外的功能。例如，需要打印函数的执行日志，一种方法是在业务函数中添加打印日志语句；但是，当函数数量很多时，这种方法就显得不那么靠谱，而且程序中会充斥着大量的重复代码，影响程序的可读性。这时，装饰器就能够发挥很大的作用。</p><a id="more"></a><h1 id="详解装饰器"><a href="#详解装饰器" class="headerlink" title="详解装饰器"></a>详解装饰器</h1><p>装饰器总的来说分为函数装饰和类装饰器，函数装饰器中又有无参数装饰器和带参数装饰器，所装饰函数也包括无参函数，一个参数或者多个参数函数，甚至是参数个数不固定的函数，以及带有关键字参数的函数。虽然这里说明了装饰的种类比较多，但是其思想完全一样。所以弄懂装饰器工作原理，这些问题也就迎刃而解了。</p><h2 id="无参函数的装饰器"><a href="#无参函数的装饰器" class="headerlink" title="无参函数的装饰器"></a>无参函数的装饰器</h2><p>无参函数的装饰器也即是所装饰函数不带有参数，具体看下面代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无参数函数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, 我是一个业务函数'</span>)</span><br><span class="line"></span><br><span class="line">func = record_logging(func)</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">hello,我是一个业务函数</span><br></pre></td></tr></tbody></table></figure><p>上面的代码实现了一个简单的装饰器，在业务函数执行之前打印正在即将执行函数名称。可以看到真正的业务函数是<code>func()</code>，其被包裹在函数<code>wrapper</code>之中。函数<code>record_logging</code>即是装饰器，它的返回值是一个函数<code>wrapper</code>，然后语句<code>func = record_logging(func)</code>在调用装饰器。这样就能够达到我们所需要的目的。在python中，使用@来告诉python，该函数需要被装饰器所装饰，这样就可以省略掉赋值语句<code>func = record_logging(func)</code>，具体如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'this function is func()'</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">hello,我是一个业务函数</span><br></pre></td></tr></tbody></table></figure><p>可以看出，其执行结果与赋值调用装饰器结果一样。而且使用@使代码更加简洁美观易读，也更加的pythonic。</p><h2 id="一个参数函数的装饰器"><a href="#一个参数函数的装饰器" class="headerlink" title="一个参数函数的装饰器"></a>一个参数函数的装饰器</h2><p>当所装饰的业务函数带有逻辑参数时，又该如何实现装饰器呢？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个参数函数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(name)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running...'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(name)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Printing parameter '{}' is my task"</span>.format(name))</span><br><span class="line"></span><br><span class="line">func(<span class="string">'Chai'</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">Printing parameter 'Love' is my task</span><br></pre></td></tr></tbody></table></figure><p>其逻辑思想与无参数函数装饰器一致，其区别仅仅在于<code>wrapper</code>函数接受业务函数参数（仔细对比无参数函数装饰器的写法）。</p><h2 id="多个参数甚至不固定参数个数函数的装饰器"><a href="#多个参数甚至不固定参数个数函数的装饰器" class="headerlink" title="多个参数甚至不固定参数个数函数的装饰器"></a>多个参数甚至不固定参数个数函数的装饰器</h2><p>这个时候我们就需要用到<code>*args</code>来代替业务函数的逻辑参数。具体使用如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running...'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">"my name is {0}, and my age is {1}"</span>.format(name, age))</span><br><span class="line"></span><br><span class="line">func(<span class="string">'CL'</span>, <span class="number">22</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">my name is CL, and my age is 22</span><br></pre></td></tr></tbody></table></figure><p>当业务函数参数较多或不固定时，只需要将函数<code>wrapper</code>的参数设置为<code>*args</code>即可。当业务函数中包含关键字参数如<code>None</code>时，设置函数<code>wrapper</code>接收<code>**kwargs</code>即可。</p><h2 id="装饰器带有参数"><a href="#装饰器带有参数" class="headerlink" title="装饰器带有参数"></a>装饰器带有参数</h2><p>带有参数的装饰器灵活度更高，其相当于与将装饰器再封装了成函数。例如，在查询函数执行日志时，不同的ID有不同的查询权限，具体如下的例子：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#带参数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_loggings</span><span class="params">(ID)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> ID==<span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'权限太低，没法儿查询'</span>)</span><br><span class="line">            <span class="keyword">elif</span> ID==<span class="number">1</span>:</span><br><span class="line">                print(<span class="string">'请稍后，正在查询...'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_loggings(ID=0)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"虽然我是一个没有参数的业务函数,但是我还是占用了*args,**kwargs哦。"</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">权限太低，没法儿查询</span><br><span class="line">虽然我是一个没有参数的业务函数,但是我还是占用了*args,**kwargs哦。</span><br></pre></td></tr></tbody></table></figure><p>函数装饰器就介绍完了。前面我们说过还有一种装饰器是类装饰器，它是通过类的<code>__call__</code>函数实现的，其具体见如下代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        print(<span class="string">'A class decorator is running...'</span>)</span><br><span class="line">        self.func(name, age)</span><br><span class="line">        print(<span class="string">'The class decorator ended...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">'my name is {0}, and my age is {1}'</span>.format(name, age))</span><br><span class="line"></span><br><span class="line">func(<span class="string">"CL"</span>, <span class="number">22</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A class decorator is running...</span><br><span class="line">my name is CL, and my age is 22</span><br><span class="line">The class decorator ended...</span><br></pre></td></tr></tbody></table></figure><p>这是一个简单的类装饰器，可以看到装饰器的本质还是体现在函数<code>__call__</code>上面（包括参数的传递等），可仔细体会其与函数装饰器之间的异同。</p><h1 id="python中内置装饰器"><a href="#python中内置装饰器" class="headerlink" title="python中内置装饰器"></a>python中内置装饰器</h1><p>在python中常见的内置装饰器有</p><ul><li>@property 把方法变成属性调用</li><li>@staticmethod 静态方法，用来修饰类中的方法，可以使类方法像字段属性一样调用。</li><li>@classmethod 类方法，与@staticmethod类似，@classmethod需要将class传入被修饰的方法中。</li></ul><p>具体的使用方法可以查看官方文档。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文仔细梳理了python中的装饰器工作原理，以及不同装饰器的实现方法，简单介绍了类装饰器。本文作为python装饰器学习之后的一个笔记，记录在此，以备后查！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python,python装饰器@ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+hexo搭建个人博客全过程</title>
      <link href="/2020/04/23/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/04/23/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们用github和hexo博客框架来搭建一个属于自己的个人博客。纯新手小白入，在搭建的过程中，我会详细整理步骤，每一步中应该注意的事项。生命不息，折腾不止。let’s go!</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在开始整个的博客搭建之前，我们要先准备好需要用到的东西。</p><ol><li>github账号一个</li><li>安装博客框架hexo</li></ol><a id="more"></a><h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><p>首先就是github账号，这个到<a href="https://github.com/" target="_blank" rel="noopener">官网</a>注册一个就好啦。然后新建一个仓库，仓库名称有固定的写法：<strong>用户名</strong>.github.io。这里的“用户名”指的是你注册GitHub账号时的用户名。</p><center><img src="http://q96n545no.bkt.clouddn.com/FhJr2DiIphjhdUjcNQSoPfCsTq32" ,width="50%" ,="" height="30%">Fig 1. 新建仓库"**用户名**.github.io"</center><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>Ok,现在解决第二个东东，安装hexo,这个也是整个过程中稍显复杂的一步。因为要安装它还要先安装另外两个小东西。按照步骤一步一步来，也没有什么麻烦的。我们首先需要安装git,这个东西是一个开源的分布式版本控制系统，想了解更多的小伙伴可以查看廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a>：。我们这里为什么要安装它，因为我们在本地搭建好博客之后，需要用它跟我们的GitHub同步。现在从<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网</a>选择适合自己电脑的版本下载安装。安装完成之后可以从命令行中输入git查看是否安装成功。</p><center><img src="http://q96n545no.bkt.clouddn.com/Fq0v3r1hGjobVLz54x7jyMDLaVam">fig 2. 查看git是否安装成功</center><p>成功安装之后，我们需要将git于github这两兄弟绑在一起。在菜单栏里面搜索<code>Git Bash</code>，配置user.name和user.email信息，如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 这里填你的GitHub用户名</span><br><span class="line">git config --global user.name 这里填你的GitHub注册邮箱</span><br></pre></td></tr></tbody></table></figure><p>现在就需要生成密钥文件啦，用来将git和GitHub对应起来。<br>再输入</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 这里填你的GitHub注册邮箱</span><br></pre></td></tr></tbody></table></figure><p>一路回车整起来，然后找到密钥文件，一般是在用户文件夹下的.ssh文件夹里面的”id_rsa.pub”，打开并全部复制，打开<a href="https://github.com/settings/keys" target="_blank" rel="noopener">页面</a>,新建一个SSH key。设置过程中，title字段随意，Key字段粘贴刚才复制的内容，Add SSH key。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>现在就该安装第二个小东西了Node.js。因为hexo是基于Node.js的，所以我们需要<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">下载</a>安装它，可在命令行中输入<code>node -v</code>查看是否安装成功。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>到了这里终于可以安装主角hexo了。我们现在自己电脑上新建一个文件夹hexo_blog，然后在该hexo_blog中打开命令行，使用npm安装hexo(忘了说了，这个npm在安装Node.js时就一起安装好了的)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure><p>安装完成之后呢，我们还是在这个目录下初始化博客，用下面的命令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></tbody></table></figure><p>到这里为止，一个博客雏形就有了哦，是不时特别期待瞧瞧自己的博客<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8">😎</span><br>在文件夹blog下打开命令行，输入如下三条命令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new test</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>在浏览器中输入localhost:4000就可以查看搭建好的博客啦<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8">👊</span></p><p>走到这里，我们就已经基本搭建好了我们的个人博客。但是呢，这样的博客还是比较简陋的，所以我们还得继续折腾，let’s go。咳咳，先解释下上面三条命令，分别是新建一篇博客，生成博客，本地预览，哦了。现在我们得把它从本地部署到github上面。开始下面工作的之前，先说明两个文件哈的称谓，为了我们后面方便叙述。<br><strong>站点配置文件</strong> blog文件夹下面的_config.yml<br><strong>主题配置文件</strong> blog文件夹下的theme文件夹下的_config.yml<br>下面设置将本地文件部署到github，打开站点配置文件，添加如下内容，需要注意的是这个有缩进的(这个可以参考下文件里面的其他地方写法)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo: https://github.com/用户名/用户名.github.io.git</span><br><span class="line"> branch: master</span><br></pre></td></tr></tbody></table></figure><p>最后安装要给一个git部署插件(在blog文件夹下)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><p>现在就可以用如下命令部署自己的博文啦</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure><p>大功告成！现在就可以在浏览器中输入<code>用户名.github.io</code>，就可以在网络上访问我们自己的博客了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>后面基本上就是对博客的一些优化了，比如更换主题啊，美化博客呀这些。这些就比较简单啦，网上也有很多很好的教程给大家参考。哦了。就写到这些里吧。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">emoji使用</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 有用的小仓库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写在开始</title>
      <link href="/2020/04/23/hello-world/"/>
      <url>/2020/04/23/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>经过大概两三天的样子的折腾，第一个个人博客终于是搭建好了！搭建过程中遇到了很多问题，可总也摸索着解决掉了，现在一个可简单使用的个人博客就这么捣鼓成了。面对一个被自己创造出来的东西，人们总是很欣喜的，而我也不例外。<a id="more"></a>总要在它诞生之初说点什么，好像是对它的尊重，也好像是对自己的尊重，也更像是一种仪式。就像一个刚出生的婴儿，落地之时的哇哇哭声，新手程序员的 “hello world”。恰好，这段文字就是诞生之日的一点声音，一句问候 “hello world”。</p><center><img src="http://q96n545no.bkt.clouddn.com/FquUVYSyHbEqjzc36xfy9SF3OIh3"></center><h2 id="唠吧"><a href="#唠吧" class="headerlink" title="唠吧"></a>唠吧</h2><p>感觉好多话想说说，可是一到要写成文字的时候，却又不知道该说些什么了好。老早的时候就想搭建一个自己的个人博客，可是由于种种的原因，一直没有付诸到行动中上，就拖沓至今了。幸好利用这段稍显空闲的时间，也是完成了之前的一个愿想吧，终于心满意足。窗外淅淅沥沥的下着小雨，播放器里传出周董的 ‘<a href="https://y.qq.com/portal/search.html#page=1&amp;searchid=1&amp;remoteplace=txt.yqq.top&amp;t=song&amp;w=%E7%AE%80%E5%8D%95%E7%88%B1" target="_blank" rel="noopener">河边的风 在吹着头发 飘动</a>‘, 伏在案前一边查资料搭建博客，一边偶尔解决她的各种各样小问题(虽然有时解决的不是很完美吧，可是我也是很认真的在思考解决了的哦<img src="http://www.webpagefx.com/tools/emoji-cheat-sheet/graphics/emojis/bowtie.png" height="20" width="20" align="absmiddle">)。一直在想，以后要在这上面记录一些什么东西呢，生活？学习？或者是读过的书，看过的电影，又或者是一些想法，一些感悟？嗯，都有可能吧，反正现在还没确定好它的主要作用，暂且就当作我的一个记事本吧。想到什么就写些什么<img src="http://www.webpagefx.com/tools/emoji-cheat-sheet/graphics/emojis/sunglasses.png" height="20" width="20" align="absmiddle">，这样也就不会太过于纠结，写起来会更轻松惬意一些。希望以后自己能坚持下来，多写一些东西，多思多想。</p><h2 id="该收尾啦"><a href="#该收尾啦" class="headerlink" title="该收尾啦"></a>该收尾啦</h2><p>既然决定了开始一件事儿，所以，就来吧。我还是喜欢”来日方长”这个词儿，这不代表我不就珍惜当下。诸君来日方长。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情， 感悟，文字 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
