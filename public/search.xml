<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>矩阵迹的求导</title>
      <link href="/2021/12/02/%E7%9F%A9%E9%98%B5%E8%BF%B9%E7%9A%84%E6%B1%82%E5%AF%BC/"/>
      <url>/2021/12/02/%E7%9F%A9%E9%98%B5%E8%BF%B9%E7%9A%84%E6%B1%82%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="关于矩阵迹的一些求导法则"><a href="#关于矩阵迹的一些求导法则" class="headerlink" title="关于矩阵迹的一些求导法则"></a>关于矩阵迹的一些求导法则</h1><h2 id="一、迹的基本性质"><a href="#一、迹的基本性质" class="headerlink" title="一、迹的基本性质"></a>一、迹的基本性质</h2><ul><li>线性性质：$tr(\sum_ic_iA_i)=\sum_ic_itr(A_i)$</li><li>转置不变性：$tr(A)=tr(A^T)$</li><li>轮换不变性 $tr(ABC)=tr(BCA)=tr(CAB)$</li></ul><p><strong>注意：轮换不变性不等于交换性，例如$tr(ABC)\neq tr(ACB)$</strong></p><h2 id="二、迹的求导规则"><a href="#二、迹的求导规则" class="headerlink" title="二、迹的求导规则"></a>二、迹的求导规则</h2><ol><li><p>$\dfrac{\partial tr(AB)}{\partial A}=\dfrac{\partial tr(BA)}{\partial A}=B^T$</p></li><li><p>$\dfrac{\partial tr(A^TB)}{\partial A}=\dfrac{\partial tr(BA^T)}{\partial A}=B$</p></li><li><p>$\dfrac{\partial tr(A^TBA)}{\partial A}=BA+B^TA$</p></li><li><p>$\dfrac{\partial (ABA^T)}{\partial A}=AB^T+AB$</p></li><li><p>$\dfrac{\partial tr(AXBXC^T)}{\partial X}=A^TCX^TB^T+B^TX^TA^TC$</p></li><li><p>$\dfrac{\partial tr(AXBX)}{\partial X}=A^TX^TB^T+B^TX^TA^T$</p></li><li><p>$\dfrac{\partial tr(AXBX^T)}{\partial X}=A^TXB^T+AXB​$</p></li><li><p>$\dfrac{\partial tr(A^TXB^T)}{\partial X}=\dfrac{\partial tr(AX^TB)}{\partial X}=AB$</p></li><li><p>$\dfrac{\partial tr(A^TXB)}{\partial X}=AB^T$</p></li><li><p>$\dfrac{\partial tr(A^TX^TXA)}{\partial X}=2XAA^T$</p></li><li><p>$\dfrac{\partial tr[(XA-B)^T(XA-B)]}{\partial X}=2(XA-B)A^T$</p><p><strong>核心公式：$\nabla tr(XAX^TB)=B^TXA^T+BXA$</strong></p><p>​</p><p>​</p><p>​</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在sublime text3中使用python虚拟环境</title>
      <link href="/2021/11/09/%E5%9C%A8sublime%20text3%E4%B8%AD%E4%BD%BF%E7%94%A8python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2021/11/09/%E5%9C%A8sublime%20text3%E4%B8%AD%E4%BD%BF%E7%94%A8python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="在sublime-text3上使用python虚拟环境–记录"><a href="#在sublime-text3上使用python虚拟环境–记录" class="headerlink" title="在sublime text3上使用python虚拟环境–记录"></a>在sublime text3上使用python虚拟环境–记录</h1><ol><li><p>在cmd窗口中使用<code>conda</code>命令创建虚拟环境，具体为</p> <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n venv-name python=3.8.5</span><br></pre></td></tr></tbody></table></figure><p> 其中，<code>venv-name</code>是所创建的虚拟环境名字，<code>python=3.8.5</code>可以指定python的版本。</p></li><li><p>如何在虚拟环境中安装库？首先利用<code>conda activate venv-name</code>激活虚拟环境，然后在虚拟环境<code>pip install package-name</code>安装即可，或者<code>pip install -r requirements.txt</code>批量安装。</p><p> <strong>注意：</strong>如果使用了国内镜像源安装，一定要关闭本地电脑上的代理服务器。</p><p> 到目前为止，已经创建好python虚拟环境。接下来在sublime text3中使用该虚拟环境</p> <a id="more"></a></li><li><p>打开sublime text3, <code>Ctrl+Shift+P</code>输入conda，安装conda插件。</p></li><li><p>添加虚拟环境<code>Preferences---Package-Settings--Conda--Settings</code>，修改如下：</p><p> <img src="D:%5CBlog%5Cblog%5Csource%5Cimages%5Cconda.png" alt=""></p></li></ol><p><code>executable</code>为anaconda的安装路径，<code>enviroment_directary</code>为虚拟环境所在目录，<code>run_through_shell</code>是否允许程序运行中弹出窗口（比如matplotlib，pygame等窗口）。</p><ol start="5"><li><p>激活虚拟环境。<code>Ctrl+Shift+P</code>，输入conda，选择合适的选项激活需要的虚拟环境。</p></li><li><p>选择conda环境，<code>Tools--Build System--conda</code>即可。</p><p> <strong>注意：如果需要从虚拟环境切换到本地主base环境时，仍然要选择<code>conda</code>，而不是<code>python</code>。</strong></p></li><li><p><code>Ctrl+B</code>运行代码！</p><p> <strong>大功告成</strong></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人类移动规律的可预测性</title>
      <link href="/2021/10/22/%E4%BA%BA%E7%B1%BB%E7%A7%BB%E5%8A%A8%E8%A7%84%E5%BE%8B%E7%9A%84%E5%8F%AF%E9%A2%84%E6%B5%8B%E6%80%A7/"/>
      <url>/2021/10/22/%E4%BA%BA%E7%B1%BB%E7%A7%BB%E5%8A%A8%E8%A7%84%E5%BE%8B%E7%9A%84%E5%8F%AF%E9%A2%84%E6%B5%8B%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>文献：Song C, Qu Z, Blumm N, et al. Limits of predictability in human mobility. Science, 2010, 327(5968): 1018-1021.</p><p>地址：<a href="https://www.science.org/doi/10.1126/science.1177170" target="_blank" rel="noopener">Limits of predictability in human mobility</a></p><blockquote><p>A range of applications, from predicting the spread of human and electronic viruses to city planning and resource management in mobile communications, depend on our ability to foresee the whereabouts and mobility of individuals, raising a fundamental question: To what degree is human behavior predictable? Here we explore the limits of predictability in human dynamics by studying the mobility patterns of anonymized mobile phone users. By measuring the entropy of each individual’s trajectory, we find a 93% potential predictability in user mobility across the whole user base. Despite the significant differences in the travel patterns, we find a remarkable lack of variability in predictability, which is largely independent of the distance users cover on a regular basis.</p></blockquote><h1 id="1-计算user的熵率"><a href="#1-计算user的熵率" class="headerlink" title="1. 计算user的熵率"></a>1. 计算user的熵率</h1><p>$X_i$是随机变量，表示在时间$i$​时，user所在位置。Entropy定义为<br>$$<br>S=-\sum_{x\in X}P(x)log_2p(x)<br>$$<br> $p(x)=Pr\lbrace X=x\rbrace$。</p><p>给定$X$，随机变量$Y$​的条件概率熵为<br>$$<br>S(Y|X)\equiv \sum_{x\in X}p(x)S(Y|X=x)<br>$$</p><a id="more"></a><p>假设$h_n$是n个locations序列的随机变量。对于平稳随机过程$\mathcal{X}={X_i}$,熵率可表示为<br>$$<br>\begin{split}<br>    S &amp;\equiv \lim_{n\to \infty}\dfrac{1}{n}S(X_1, X_2, \cdots, X_n)\<br>      &amp; = \lim_{n\to \infty}\dfrac{1}{n}\sum_{i=1}^{n}S(X_i|h_{i-1})\<br>      &amp; = \lim_{n\to \infty} \dfrac{1}{n}\sum_{i=1}^{n}S(i)<br>\end{split}<br>$$<br><strong>如果下一时刻所处位置与当前位置无关</strong>，则有$S=-\sum_{i}p_i\log_2p_i$, $p_i$表示在位置$i$的概率。</p><ul><li>$S_i$: user i的真实的熵，同时包含时间和空间模式</li><li>$S^{unc}=-\sum_{i=1}^np_i\log_2p_i$: 不考虑时间相关性</li><li>$S^{rand}=\log_2N$: 随机熵。</li></ul><p><strong>显然有</strong>, $0\leq S \leq S^{unc} \leq S^{rand} \le \infty $.</p><h1 id="2-估计真实的熵-S"><a href="#2-估计真实的熵-S" class="headerlink" title="2. 估计真实的熵$S$"></a>2. 估计真实的熵$S$</h1><p>基于Lempel-Ziv数据压缩的估计，<br>$$<br>S^{est}=\left(\dfrac{1}{n}\sum_i\Lambda_i \right)^{-1}\ln n<br>$$<br>$\Lambda_i$是从位置$i$出发的最短子串的长度，且该子串在位置1到位置$i-1$中没有出现过。当$n\to \infty$时，$S^{est}$收敛于真实熵。</p><p><strong>应用公式（4）估计实际位置序列的熵时，获得的值依赖于序列中未知位置的比例q</strong></p><p>序参量$\sigma(q’)\equiv \ln\dfrac{S(q’)}{S^{unc}(q’)}$, 为了准确估计$S_i=S_i(q=0)$, 采用如下的算法：</p><ol><li>对于一个未知位置为$q$的序列，选择$\Delta q$的已知位置，并将其位置标记为“未知”。</li><li>记$q’=q + \Delta q$， $\Delta q=0, 0.05, 0.10, 0.15, \cdots, 0.9-q$, 计算序参量$\sigma(q’)\equiv \ln\left(s^{eff}(q’)\right)= \ln\dfrac{S(q’)}{S^{unc}(q’)}$ 。其中，$S(q’)$利用Lempel-Ziv算法计算，$S^{unc}(q’)$由随机打乱之后的序列，通过Lempel-Ziv算法计算。 </li></ol><p>$\sigma(q’)$与 $q’$之间存在线性关系，可以计算当 $q=0$时 $\sigma_{est}$，则 $S^{est}=e^{\sigma_{est}}S^{unc}$.</p><p>$sin{x-2y}=0$</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 可预测性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些tikz绘图例子</title>
      <link href="/2020/10/21/%E4%B8%80%E4%BA%9Btikz%E4%BE%8B%E5%AD%90/"/>
      <url>/2020/10/21/%E4%B8%80%E4%BA%9Btikz%E4%BE%8B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="tikz的一些画图例子"><a href="#tikz的一些画图例子" class="headerlink" title="tikz的一些画图例子"></a>tikz的一些画图例子</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>在此记录一些tikz绘制图形的例子，以方便后续使用。</strong></p><a id="more"></a><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><p>代码如下：</p><pre class="prettyprit lang-tex">\documentclass{article}\usepackage{tikz}\begin{document}\usetikzlibrary{intersections}\begin{tikzpicture}[scale=3]%\clip[draw] (-0.8,-0.2) rectangle (1.1,1.75);\draw[-&gt;] (-1.5, 0) -- (1.5,0)node [right] {$x$} coordinate (x axis);\draw[-&gt;] (0, -1.5) -- (0,1.5)node [above] {$y$} coordinate (y axis);\draw (0,0) circle [radius=1cm];\draw[step=0.5cm,gray,very thin] (-1.4, -1.4) grid  (1.4,1.4) ;\filldraw[fill=green!20!white, draw=green!50!black] (0mm,0mm) -- (3mm,0mm) arc [start angle=0,end angle=30,radius=3mm] -- cycle;\draw (15:2mm) node {\color{green!50!black}$\alpha$};\draw[red,very thick] (30:1cm) -- node[left=1pt,fill=white]{$\sin\alpha$} (30:1cm |- x axis);\draw[blue,very thick] (30:1cm |- x axis) -- node[below=1pt,fill=white]{$\cos\alpha$} (0,0);\path[name path=upward line] (1,0) -- (1,1);\path[name path=sloped line] (0,0) -- (30:2cm);\draw[name intersections={of=upward line and sloped line, by=x}] [very thick, orange] (1,0) --      node[right=1pt,fill=white]{$\tan\alpha=\frac{\color{red}\sin\alpha}{\color{blue}\cos\alpha}$} (x);\draw (0,0) -- (x);\foreach \x/\xtext in {-1/-1, -0.5/-\frac{1}{2}, 1} \draw (\x cm, 1pt) -- (\x cm, -1pt) node[anchor=north,fill=white] {$\xtext$};\foreach \y/\ytext in {-1,-0.5/-\frac{1}{2},0.5/\frac{1}{2},1} \draw ( 1pt,\y cm) -- (-1pt, \y cm) node[anchor=east,fill=white] {$\ytext$};\end{tikzpicture}\end{document}</pre><p>生成图形如下：<br><img src="/images/example1.png" alt=""></p><p><a href="/download/lesson_1.tex">点击下载源文件</a></p><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><p>代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{article}</span><br><span class="line">\usepackage{tikz}</span><br><span class="line">\begin{document}</span><br><span class="line">\usetikzlibrary[arrows.meta,decorations.pathmorphing,backgrounds,positioning,fit,petri]</span><br><span class="line">\begin{tikzpicture}</span><br><span class="line">  [bend angle=45, node distance=1.3cm, on grid, auto,</span><br><span class="line">  place/.style={circle, draw=blue!50,fill=blue!20, thick, inner sep=0pt, minimum size=6mm},</span><br><span class="line">  red place/.style={place, draw=red!75, fill=red!20},</span><br><span class="line">  transition/.style={rectangle, draw=black!50,fill=black!20, thick, inner sep=0pt, minimum size=4mm},</span><br><span class="line">  every label/.style={red},</span><br><span class="line">  pre/.style={-&gt;, shorten &gt;=1pt, &gt;={Stealth[round]}, semithick},</span><br><span class="line">  post/.style={&lt;-, shorten &lt;=1pt, &gt;={Stealth[round]}, semithick}] % 预定义样式</span><br><span class="line"></span><br><span class="line">  \node [place, tokens=1] (a1) {};</span><br><span class="line">  \node [place] (a2) [below of=a1] {};</span><br><span class="line">  \node [place] (a3) [below of=a2, label=above:$\color{red}s\leq 3$] {};</span><br><span class="line">  \node [transition] (b1) [left of=a2] {};</span><br><span class="line">  \node [transition] (b2) [right of=a2] {};</span><br><span class="line">  \draw (a1) edge [pre, bend right] (b1) edge [post, bend left] node [auto] {2} (b2);</span><br><span class="line">  \draw (a3) edge [pre, bend right] (b2) edge [post, bend left] (b1);</span><br><span class="line">  \draw (a2) edge [post] (b1) edge [pre] (b2);</span><br><span class="line"></span><br><span class="line">  \node [place] (a4) [below of=a3] {};</span><br><span class="line">  \node [place] (a5) [below of=a4, tokens=1] {};</span><br><span class="line">  \node [transition] (b3) [left of=a4] {} edge [pre, bend left] (a3) edge [pre] (a4) edge [post, bend right] (a5);</span><br><span class="line">  \node [transition] (b4) [right of=a4] {} edge [pre, bend left] node [auto] {2} (a5) edge [post, bend right] (a3) edge [post] (a4);</span><br><span class="line"></span><br><span class="line">  \begin{scope}[xshift=6cm]</span><br><span class="line">    \node [place,tokens=1] (a1') {};</span><br><span class="line">    \node [place] (a2') [below of=a1'] {};</span><br><span class="line">    \node [transition] (b1') [left of=a2'] {} edge [post, bend left] node [auto,swap] {2} (a1') edge [pre] (a2');</span><br><span class="line">    \node [transition] (b2') [right of=a2'] {} edge [pre, bend right] (a1') edge [post] (a2');</span><br><span class="line"></span><br><span class="line">    \node [red place] (a31') [below of=a2', xshift=-5mm, label=left:$\color{red}s$] {} edge [post] (b1') edge [pre] (b2');</span><br><span class="line">    \node [red place, tokens=3] (a32') [below of=a2', xshift=5mm, label=right:$\color{red}\bar{s}$] {} edge [post] (b2') edge [pre] (b1');</span><br><span class="line"></span><br><span class="line">    \node [place] (a4') [below of =a31',xshift=5mm] {};</span><br><span class="line">    \node [transition] (b3') [left of=a4'] {} edge [pre] (a31') edge [pre] (a4') edge [post] (a32');</span><br><span class="line">    \node [transition] (b4') [right of=a4'] {} edge [pre] (a32') edge [post] (a31') edge [post] (a4');</span><br><span class="line"></span><br><span class="line">    \node [place,tokens=1] (a5') [below of=a4'] {} edge [post,bend right] node [auto] {2} (b4') edge [pre, bend left] (b3');</span><br><span class="line">  \end{scope}</span><br><span class="line"></span><br><span class="line">  \begin{scope}[on background layer]</span><br><span class="line">    \node (r1) [fill=black!10, rounded corners,fit=(a1)(a2)(b1)(b2)(a3)(a4)(b2)(b3)(a5)] {};</span><br><span class="line">    \node (r2) [fill=black!10, rounded corners,fit=(a1')(a2')(b1')(b2')(a31')(a32')(a4')(b2')(b3')(a5')] {};</span><br><span class="line">  \end{scope}</span><br><span class="line"></span><br><span class="line">  \draw [shorten &gt;=1mm,-to,thick,decorate, decoration={snake,amplitude=0.4mm,segment length=2mm, pre=moveto,pre length=1mm,post length=2mm}]</span><br><span class="line">    (r1) -- (r2) node [above=1mm,midway,text width=3cm,align=center]</span><br><span class="line">    {replacement of the \textcolor{red}{capacity} by \textcolor{red}{two places}};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\end{tikzpicture}</span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p>生成图形如下：<br><img src="/images/example2.png" alt=""><br><a href="/download/lesson_2.tex">点击下载源文件</a></p><h2 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h2><p>代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{standalone}</span><br><span class="line">\usepackage{tikz}</span><br><span class="line">\begin{document}</span><br><span class="line">\usetikzlibrary{backgrounds, calc, intersections, through}</span><br><span class="line">\begin{tikzpicture}</span><br><span class="line">  \coordinate [label=left:\textcolor{blue}{$A$}] (A) at (0,0);</span><br><span class="line">  \coordinate [label=right:\textcolor{blue}{$B$}] (B) at (1.25, 0.25);</span><br><span class="line">  \draw (A) edge [blue] (B);</span><br><span class="line">  \node [name path=D,draw,label=left:$D$] (D) at (A) [circle through=(B)] {};</span><br><span class="line">  \node [name path=E,draw,label=right:$E$] (E) at (B) [circle through=(A)] {};</span><br><span class="line">  \path [name intersections={of=D and E,by={[label=above:\textcolor{red}{$C$}]C, [label=below:\textcolor{red}{$C'$}]C'}}];</span><br><span class="line">  \draw (C) edge [red] (A) edge[red] (B);</span><br><span class="line">  \foreach \point in {A,B,C}</span><br><span class="line">  \fill [black, opacity=0.5] (\point) circle (2pt);</span><br><span class="line">  \begin{pgfonlayer}{background}</span><br><span class="line">  \fill [orange!80] (A) -- (B) -- (C) -- cycle;</span><br><span class="line">  \end{pgfonlayer}</span><br><span class="line">\end{tikzpicture}</span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p>生成图形如下：<br><img src="/images/example3.png" alt=""><br><a href="/download/lesson_3.tex">点击下载源文件</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LaTeX, tikz, Tex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热图, 斑图, 色度图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python读写.csv, .txt, .xls文件</title>
      <link href="/2020/07/11/python%E8%AF%BB%E5%8F%96excel%E6%96%87%E4%BB%B6/"/>
      <url>/2020/07/11/python%E8%AF%BB%E5%8F%96excel%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>在处理数据时， 我们的第一步工作往往是将数据导入到处理软件中，本文以python读取excel文件为例，作一个简短的记录！</p><h1 id="1-读写文本文件（-csv-txt）"><a href="#1-读写文本文件（-csv-txt）" class="headerlink" title="1. 读写文本文件（.csv, .txt）"></a>1. 读写文本文件（.csv, .txt）</h1><p>python中numpy库, pandas库以及csv库都可以读入.csv文件，np.loadtxt函数可以加载.txt文件，但是值得注意的是它是将文本文件导入为数组格式。下面来简单总结下这几种方法。</p><a id="more"></a><h2 id="1-0-csv库"><a href="#1-0-csv库" class="headerlink" title="1.0 csv库"></a>1.0 csv库</h2><h3 id="1-0-0-读文件"><a href="#1-0-0-读文件" class="headerlink" title="1.0.0 读文件"></a>1.0.0 读文件</h3><p>csv在读取文件时，值得注意的是一行一行读取，并且将每一行保存为一个列表，列表中的每个元素都是字符串类型。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    rows = csv.reader(f)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        process(row)</span><br></pre></td></tr></tbody></table></figure><p>其中，<code>rows</code>是一个迭代器，<code>row</code>是表格中的每一行元素，且是一个list.因此在访问数据时，需要用到列表元素访问方法。</p><p>还有一种就是将文件读取出<strong>字典格式</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    rows = csv.DictReader(f)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        process(row)</span><br></pre></td></tr></tbody></table></figure><p>如此，在访问元素时可以使用字典访问元素方法，如<code>row['key']</code>。</p><h3 id="1-0-1-写文件"><a href="#1-0-1-写文件" class="headerlink" title="1.0.1 写文件"></a>1.0.1 写文件</h3><p>csv在将数据写入.csv是同样是一行一行写入的。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow(headers)</span><br><span class="line">    f_csv.writerow(data)</span><br></pre></td></tr></tbody></table></figure><p><code>headers</code>是数据的列名, 为列表形式，<code>data</code>是待写入的数据，其格式为<code>[(a11, a12, a13), (a21, a22, a23), (a31, a32, a33)]</code>。<br>同样可以将字典格式写入.csv</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictWriter(f, headers)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    f_csv.writerows(data)</span><br></pre></td></tr></tbody></table></figure><p>其中，<code>headers</code>是列表形式的列名。<code>data</code>是待写入的数据，其格式为<code>[{'a':1, 'b':2, 'c':3}, {'a':1.1, 'b':1.2, 'c':1.3}, {'a':2.1, 'b':2.2, 'c':2.3}]</code>。<br>现在基本上将csv库读写.csv文件做了简单的说明。下面再说说如用利用numpy库读写.csv文件。</p><h2 id="1-1-pandas-read-csv"><a href="#1-1-pandas-read-csv" class="headerlink" title="1.1 pandas.read_csv()"></a>1.1 pandas.read_csv()</h2><p>先来看看该函数中参数的具体解析</p><blockquote><p>pandas.read_csv(filepath, sep=’, ‘, usecols=None, engine=None, header=’infer’,skipfooter=0)</p></blockquote><blockquote><ol start="0"><li>filepath可以是一个本地文件，也可以是一个url。</li><li>sep是指定文件的分隔符。</li><li>usecols是一个列的子集。指定需要读取文件中的哪些列。</li><li>engine指定使用的解释器。{‘c’, ‘python’}二选一。</li><li>header指定文件中的第几行作为列名，默认是数据最开始的那一行。如果文件中没有列名，则默认为0，否则设置为None。如果明确设定header=0就会替换掉原来存在列名。</li><li>skipfooter：文件底部要跳过的行数（不支持引擎=’c’）。</li></ol></blockquote><p>注意的是使用pandas.read_csv()读取.csv文件时，数据中的某行必须作为列的标签。</p><h2 id="1-2-DataFrame-to-csv"><a href="#1-2-DataFrame-to-csv" class="headerlink" title="1.2 DataFrame.to_csv()"></a>1.2 DataFrame.to_csv()</h2><p>to_csv是pandas.DataFrame的类方法。其函数为</p><blockquote><p>df.to_csv(filename, sep=’,’, na_rep=’NA’, float_format=’%.2f’, columns=[‘name’], header=0, index=0)<br>0. filename是保存的文件名。</p><ol><li>sep指定分割符。</li><li>na_rep替换空值，默认为空。</li><li>float_format指定保留小数的位数。</li><li>columns指定需要保存的列。</li><li>header是否需要保存列名。</li><li>index是否保存行索引。</li></ol></blockquote><h2 id="1-3-numpy-loadtxt"><a href="#1-3-numpy-loadtxt" class="headerlink" title="1.3 numpy.loadtxt()"></a>1.3 numpy.loadtxt()</h2><p>直接来看函数参数</p><blockquote><p>numpy.loadtxt(filename, dtype=, comments=’#’, delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0)</p></blockquote><blockquote><ol><li>filename文件名。</li><li>dtype指定元素的数据类型，’int’, ‘float’等。</li><li>comments指定注释行不读取，即若某一行以#开头，则该行不读取。</li><li>delimiter指定文件的分割符。</li><li>converters是对数据进行预处理的参数, 我们可以先定义一个函数func1， 这里的converters是一个字典, 如{0: func1}表示第零列使用函数func1来进行预处理</li><li>skiprows指定跳过前多少行之后再读取文件。</li><li>usecols指定读取文件的哪些列。</li><li>若unpack=True,则把每一列当成一个向量进行输出，而不合并在一起。</li></ol></blockquote><p>以上简单记录了在python中如何读写<strong>.csv, .txt文件</strong>，下面再看一看如何读写<strong>.xls文件</strong>。</p><h1 id="2-读写excel文件-xls"><a href="#2-读写excel文件-xls" class="headerlink" title="2. 读写excel文件(.xls)"></a>2. 读写excel文件(.xls)</h1><p>在python中读写.xls文件主要会用到<strong>xlrd</strong>和<strong>xlwt</strong>这两个库，下面就来详细看一下具体如何操作。</p><h2 id="2-0-读-xls文件-xlrd"><a href="#2-0-读-xls文件-xlrd" class="headerlink" title="2.0 读.xls文件(xlrd)"></a>2.0 读.xls文件(xlrd)</h2><p>用一段代码来说明python具体怎么读入.xls文件的。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line">workbook = xlrd.open_workbook(filename)</span><br><span class="line">sheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">nrows = worksheet.nrows</span><br><span class="line">ncols = worksheet.ncols</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nrows):</span><br><span class="line">    print(worksheet.row_values(i))</span><br></pre></td></tr></tbody></table></figure><p>来简单解释下上面代码的含义，首先导入<code>xlrd</code>库，第二行打开.xls文件，第三行指定表格中的sheet,可以用<code>sheet_by_index</code>根据sheet的序号来指定，也可以用<code>sheet_by_name</code>根据sheet的名字来指定。第三四行输出表格的行数和列数。第五六行是用<code>row_values(i)</code>来按行读取数据，也可以用<code>col_values(i)</code>来按列读取，当然也可以用<code>cell_value(i, j)</code>来获取单元格的值。</p><h2 id="2-1-写入-xls文件-xlwt"><a href="#2-1-写入-xls文件-xlwt" class="headerlink" title="2.1 写入.xls文件(xlwt)"></a>2.1 写入.xls文件(xlwt)</h2><p>同样先来看一段代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line">book = xlwt.Workbook(encoding=<span class="string">'utf-8'</span>, style_compression=<span class="number">0</span>)</span><br><span class="line">sheet = book.add_sheet(<span class="string">'sheet1'</span>, cell_overwrite_ok=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, w1.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, w1.shape[<span class="number">1</span>]):</span><br><span class="line">        sheet.write(i, j, w1[i, j])</span><br><span class="line">book.save(filename)</span><br></pre></td></tr></tbody></table></figure><p>挑重点讲，第一行先新建一个workbook，然后在其中添加一个名为’sheet1’的<code>sheet</code>, 最后利用<code>.write(row, col, value)</code>方法来写入数据，最后将workbook进行保存。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>以上就是本文的全部内容， 主要记录了利用python来读写.csv,.txt,.xls文件的一些方法，当然本文仅仅知识针对本地文件的读取，不涉及从SQL, MongoDB数据库中读取，也没有涉及到json的读写和解析。相信上面的这些方法已经足够应付我们遇到的问题了~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python, csv, xlrd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> excel files, xls, csv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python绘制热图</title>
      <link href="/2020/06/09/%E6%96%91%E5%9B%BE/"/>
      <url>/2020/06/09/%E6%96%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要用到python来绘制热图（斑图， 色度图），查阅资料之后发现主要使用matplotlib库中的imshow函数来实现。</p><h1 id="函数参数解析"><a href="#函数参数解析" class="headerlink" title="函数参数解析"></a>函数参数解析</h1><blockquote><p>matplotlib.pyplot.imshow(X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, shape=<deprecated parameter="">, filternorm=1, filterrad=4.0, imlim=<deprecated parameter="">, resample=None, url=None, *, data=None, **kwargs)[source]</deprecated></deprecated></p></blockquote><blockquote><p>X: array-like or PIL image（数组或者是图片）<br>cmap: str or Colormap(颜色映射)<br>norm: Normalize(标准化到（0， 1）区间)<br>aspect: {‘equal’, ‘auto’} or float(控制轴的纵横比)<br>interpolation: str(插值方法)，可选为( ‘none’, ‘antialiased’, ‘nearest’, ‘bilinear’, ‘bicubic’, ‘spline16’, ‘spline36’, ‘hanning’, ‘hamming’, ‘hermite’, ‘kaiser’, ‘quadric’, ‘catrom’, ‘gaussian’, ‘bessel’, ‘mitchell’, ‘sinc’, ‘lanczos’.)<br>剩下的具体参数解释可参考<a href="https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.imshow.html" target="_blank" rel="noopener">文档解释</a></p></blockquote><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p><strong>默认使用<code>nearest</code>插值方法</strong><br>example 1.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">plt.imshow(arr, interpolation=<span class="string">'nearest'</span>, cmap=<span class="string">'coolwarm'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/%E6%96%91%E5%9B%BE1.png" alt=""><br>example 2.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">plt.imshow(X, interpolation=<span class="string">'nearest'</span>, cmap=<span class="string">'coolwarm'</span>) </span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/%E6%96%91%E5%9B%BE2.png" alt=""><br>example 3.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mean = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">10000</span>).T</span><br><span class="line"></span><br><span class="line">hist, xedges, yedges = np.histogram2d(x,y)</span><br><span class="line">X,Y = np.meshgrid(xedges,yedges)</span><br><span class="line">plt.imshow(hist, interpolation=<span class="string">'nearest'</span>,cmap=<span class="string">'coolwarm'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/%E6%96%91%E5%9B%BE5.png" alt=""><br><strong>使用<code>bilinear</code>插值法</strong>(当然可选插值方法还有很多)<br>example 1. </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">plt.imshow(arr, interpolation=<span class="string">'bilinear'</span>, cmap=<span class="string">'coolwarm'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/%E6%96%91%E5%9B%BE3.png" alt=""><br>example 2.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">plt.imshow(X, interpolation=<span class="string">'bilinear'</span>, cmap=<span class="string">'coolwarm'</span>) </span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/%E6%96%91%E5%9B%BE4.png" alt=""><br>example 3.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mean = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">10000</span>).T</span><br><span class="line"></span><br><span class="line">hist, xedges, yedges = np.histogram2d(x,y)</span><br><span class="line">X,Y = np.meshgrid(xedges,yedges)</span><br><span class="line">plt.imshow(hist, interpolation=<span class="string">'bilinear'</span>,cmap=<span class="string">'coolwarn'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/%E6%96%91%E5%9B%BE6.png" alt=""><br>可以对比使用或者不使用插值方法时生成图片之间的区别。以上是比较简单的示例，例如颜色的渐变，数值的标准化等都没有涉及到，需用用到时可详细参看<a href="https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.imshow.html" target="_blank" rel="noopener">文档解释</a></p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>针对上面两个example 3. 我们也可以使用<code>hist2d</code>函数(当然还有其他的实现，例如<code>pcolor</code>,<code>matshow</code>函数等)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mean = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">cov = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">x, y = np.random.multivariate_normal(mean, cov, <span class="number">10000</span>).T</span><br><span class="line">plt.hist2d(x, y, bins=<span class="number">50</span>, cmap=<span class="string">'coolwarm'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/%E6%96%91%E5%9B%BE7.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>python中生成热图的主要方法为imshow()函数，我们看到同样还有很多其他的方法可以实现，他们可以满足不同的画图需求，本文中涉及的函数主要是<code>matplotlib</code>库中的，同样在<code>seaborn</code>中也有热图函数，比如<code>heatmap</code>，本文中介绍的热图函数已经能够满足大多数时候的需求。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python, matplotlib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热图, 斑图, 色度图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成对抗网络（一）</title>
      <link href="/2020/05/18/GAN(%E4%B8%80)/"/>
      <url>/2020/05/18/GAN(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2014年，Ian Goodfellow等人提出一种全新神经网络训练模型–生成对抗模型(Generative Adversarial Network,GAN)。GAN是近年来最火热的无监督学习算法，在此基础上，许多研究者对其不断进行改进，衍生出很多相应的算法，也逐渐将其应用到半监督和有监督学习中。该系列博客主要记录从GAN的理论推导，编程实现和将GAN应用到半监督学习中。这第一篇文章就先将GAN的理论知识和实现简单介绍下。</p><a id="more"></a><h1 id="GAN理论推导"><a href="#GAN理论推导" class="headerlink" title="GAN理论推导"></a>GAN理论推导</h1><p><img src="http://q96n545no.bkt.clouddn.com/Fl6xdArNqoypHvyOAER2DtWCf4c6" alt="原文abstract截图"><br>首先，需要知道的是生成对抗网络的设计是为了estimating generative model，而”adversarial process”是为了完成这一任务的辅助手段。<a href="https://arxiv.org/abs/1406.2661" target="_blank" rel="noopener">原论文</a>摘要中对GAN的设计思想、大致的训练过程都做了很好的说明。下面就好好学习学习GAN的具体理论部分。</p><h2 id="一些概念和约定"><a href="#一些概念和约定" class="headerlink" title="一些概念和约定"></a>一些概念和约定</h2><p>生成对抗网络主要又两个重要的部分组成：</p><ul><li>生成器（Generator):通过不断学习，生成与真实数据相仿的“假数据”，其目标是要成功“欺骗”鉴别器（Discriminator）</li><li>鉴别器（Discriminator）:尽可能将真实数据与Generator生成的“假数据”区分开来。</li></ul><p>生成器与鉴别器相辅相成，两者之间不断对抗的过程，也是二者之间不断学习的过程。结束对抗过程之后，理想情况是Generator能够生成与真实数据分布高度吻合的数据，而Discriminator已经完全不能区分出真实数据与“假数据”。因此，在原文中，作者也提到了”D equal to $\dfrac{1}{2}$ everywhere”。</p><ul><li>$p_g$:Generator通过真实数据$x$生成的分布</li><li>$p_{data}$:真实数据分布</li></ul><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>首先直接引入GAN的目标函数，然后我们再对其进行简单的说明，<br>\begin{equation}<br>\min_{G}\max_{D}V(D,G)=\mathop{\mathbb{E}}\limits_{x\sim p_{data}(x)}[\log D(x)]+\mathop{\mathbb{E}}\limits_{z\sim p_z(z)}[\log(1-D(G(z)))].<br>\end{equation}</p><p>其中，$p_z(z)$是预先定义好的噪声分布，$G(z;\theta_g)$是一个参数为$\theta_g$的可微多层感知器，$D(x;\theta_d)$也是一个多层感知器，其输出为一个标量，$D(x)$表示了$x$来自真实数据而不是$p_g$的概率。</p><p>通过训练$D$，最大化概率区分数据来自$p_{data}$还是$p_g$(显然地，$p_{data}$和$p_g$中的数据都应该进入$D$中进行鉴别)，同时训练$G$来最小化$\log(1-D(G(z)))$</p><p><strong>注：</strong>至于该目标函数是怎么来的，还没有看到一个比较认可的说法。要再好好查查！</p><h3 id="训练策略"><a href="#训练策略" class="headerlink" title="训练策略"></a>训练策略</h3><p><img src="http://q96n545no.bkt.clouddn.com/FlI7r4tybeAoLXD2nsjesfWQ4VTs" alt=""><br>Figure 1可得好好看明白，因为它描述了GAN的一个训练过程。<br>下面给出GAN算法<br><img src="http://q96n545no.bkt.clouddn.com/FmfEfocKAQRRR1ZBrb8xjkQY-u50" alt=""></p><h2 id="证明目标函数收敛"><a href="#证明目标函数收敛" class="headerlink" title="证明目标函数收敛"></a>证明目标函数收敛</h2><p>此部分需要证明GAN中的目标函数是收敛的，即是可以达到最优解的。为什么要证明目标函数是收敛的？因为该目标函数最大最小优化问题，可能不存在最优解，故需要证明是收敛的。</p><p>先证明存在最有鉴别器$D$,</p><p>知道<br>\begin{equation}<br>V(D,G)=\int_x [p_{data}(x)\log D(x)+p_g(x)\log(1-D(x))]dx<br>\end{equation}</p><p>现在，先考虑$\forall a， b$, $a\log x+b\log(1-x)$，有最大值当$x=\dfrac{a}{a+b}$时。再回到公式（2），$V(D,G)$也有最大值存在，当$D=D_G^*=\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)}$，我们知道最优鉴别器应该处处$D(x)=\dfrac{1}{2}$，因此$p_{data}(x)=p_g(x)$时，鉴别器$D$达到最优。</p><p>接下来就要证明当且仅当$p_{data}(x)=p_g(x)$时，$C(G)=\max V(D,G)$达到最小值。</p><p>$\stackrel{充分性}{\Longrightarrow}$   当$p_{data}(x)=p_g(x)$时，<br>\begin{equation}<br>\begin{split}<br>C(G)&amp;=\int_x p_{data}(x)\log(\dfrac{1}{2})+p_{g}(x)\log(\dfrac{1}{2})dx\<br>&amp;=\log(\dfrac{1}{2})(1+1)\<br>&amp;=-\log 4<br>\end{split}<br>\end{equation}</p><p>$\stackrel{必要性}{\Longleftarrow}$</p><p>$$<br>\begin{split}<br>C(G)&amp;=&amp;\int_x p_{data}(x)\log\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)}+p_g(x)\log\dfrac{p_{g}(x)}{p_{data}(x)+p_g(x)}\\<br>&amp;=&amp;\int_x(\log2-\log2)p_{data}(x)+p_{data}(x)\log\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)}\\<br>&amp;&amp;+(\log2-\log2)p_g(x)+p_{g}(x)\log\dfrac{p_{g}(x)}{p_{data}(x)+p_g(x)}dx\\<br>&amp;=&amp;-\log 2\int_x(p_{data}(x)+p_g(x))dx+\int_x p_{data}(x)(\log 2+\log\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)})dx\\<br>&amp;&amp;+\int_xp_g(x)(\log2+\log(1-\dfrac{p_{data}(x)}{p_{data}(x)+p_g(x)}))dx\\<br>&amp;=&amp;-\log4+\int_xp_{data}(x)\log\dfrac{p_{data}(x)}{(p_{data}(x)+p_g(x))/2}dx\\<br>&amp;&amp;+\int_xp_g(x)\log\dfrac{p_g(x)}{(p_{data}(x)+p_g(x))/2}dx\\<br>&amp;=&amp;-\log4+KL(p_{data}||\dfrac{p_{data}(x)+p_g(x)}{2})+KL(p_g||\dfrac{p_{data}(x)+p_g(x)}{2})\\<br>&amp;=&amp;-\log4+2JSD(p_{data}(x)||p_g(x))\geq -\log 4<br>\end{split}<br>$$</p><p>当且仅当$p_{data}(x)=p_g(x)$时，取最小值$-\log 4$，证毕。</p><h1 id="GAN实现（PyTorch）"><a href="#GAN实现（PyTorch）" class="headerlink" title="GAN实现（PyTorch）"></a>GAN实现（PyTorch）</h1><p>到目前为止，将GAN的整个理论部分过了一遍。下面开始用PyTorch来简单实现下GAN。<br>首先导入需要的库，然后构造生成器和鉴别器</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> matplotlib.mlab <span class="keyword">as</span> mlab</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, output_size, f)</span>:</span></span><br><span class="line">        super(Generator, self).__init__()</span><br><span class="line">        self.map1 = nn.Linear(input_size, hidden_size)</span><br><span class="line">        self.map2 = nn.Linear(hidden_size, hidden_size)</span><br><span class="line">        self.map3 = nn.Linear(hidden_size, output_size)</span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.map1(x)</span><br><span class="line">        x = self.f(x)</span><br><span class="line">        x = self.map2(x)</span><br><span class="line">        x = self.f(x)</span><br><span class="line">        x = self.map3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size, output_size, f)</span>:</span></span><br><span class="line">        super(Discriminator, self).__init__()</span><br><span class="line">        self.map1 = nn.Linear(input_size, hidden_size)</span><br><span class="line">        self.map2 = nn.Linear(hidden_size, hidden_size)</span><br><span class="line">        self.map3 = nn.Linear(hidden_size, output_size)</span><br><span class="line">        self.f = f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.f(self.map1(x))</span><br><span class="line">        x = self.f(self.map2(x))</span><br><span class="line">        <span class="keyword">return</span> self.f(self.map3(x))</span><br></pre></td></tr></tbody></table></figure><p>下面对输入数据做简单处理</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(name, preprocess, d_input_func) = (<span class="string">"Only 4 moments"</span>, <span class="keyword">lambda</span> data: get_moments(data), <span class="keyword">lambda</span> x: <span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(v)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> v.data.storage().tolist()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [np.mean(d), np.std(d)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_moments</span><span class="params">(d)</span>:</span></span><br><span class="line">    <span class="comment"># Return the first 4 moments of the data provided</span></span><br><span class="line">    mean = torch.mean(d)</span><br><span class="line">    diffs = d - mean</span><br><span class="line">    var = torch.mean(torch.pow(diffs, <span class="number">2.0</span>))</span><br><span class="line">    std = torch.pow(var, <span class="number">0.5</span>)</span><br><span class="line">    zscores = diffs / std</span><br><span class="line">    skews = torch.mean(torch.pow(zscores, <span class="number">3.0</span>)) <span class="comment"># 计算偏度</span></span><br><span class="line">    kurtoses = torch.mean(torch.pow(zscores, <span class="number">4.0</span>)) - <span class="number">3.0</span>  <span class="comment"># 计算峰度 excess kurtosis, should be 0 for Gaussian</span></span><br><span class="line">    final = torch.cat((mean.reshape(<span class="number">1</span>,), std.reshape(<span class="number">1</span>,), skews.reshape(<span class="number">1</span>,), kurtoses.reshape(<span class="number">1</span>,)))</span><br><span class="line">    <span class="keyword">return</span> final</span><br></pre></td></tr></tbody></table></figure><p>接下来设置超参数并开始训练GAN</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">data_mean = <span class="number">4</span></span><br><span class="line">data_stddev = <span class="number">1.25</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Model parameters</span></span><br><span class="line">    g_input_size = <span class="number">1</span>      <span class="comment"># Random noise dimension coming into generator, per output vector</span></span><br><span class="line">    g_hidden_size = <span class="number">5</span>     <span class="comment"># Generator complexity</span></span><br><span class="line">    g_output_size = <span class="number">1</span>     <span class="comment"># Size of generated output vector</span></span><br><span class="line">    d_input_size = <span class="number">500</span>    <span class="comment"># Minibatch size - cardinality of distributions</span></span><br><span class="line">    d_hidden_size = <span class="number">10</span>    <span class="comment"># Discriminator complexity</span></span><br><span class="line">    d_output_size = <span class="number">1</span>     <span class="comment"># Single dimension for 'real' vs. 'fake' classification</span></span><br><span class="line">    minibatch_size = d_input_size</span><br><span class="line"></span><br><span class="line">    d_learning_rate = <span class="number">1e-3</span></span><br><span class="line">    g_learning_rate = <span class="number">1e-3</span></span><br><span class="line">    sgd_momentum = <span class="number">0.9</span></span><br><span class="line"></span><br><span class="line">    num_epochs = <span class="number">2000</span></span><br><span class="line">    print_interval = <span class="number">100</span></span><br><span class="line">    d_steps = <span class="number">20</span></span><br><span class="line">    g_steps = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    dfe, dre, ge = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    d_real_data, d_fake_data, g_fake_data = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    discriminator_activation_function = torch.sigmoid <span class="comment"># 鉴别器激活函数</span></span><br><span class="line">    generator_activation_function = torch.tanh <span class="comment"># 生成器激活函数</span></span><br><span class="line"></span><br><span class="line">    d_sampler = get_distribution_sampler(data_mean, data_stddev)</span><br><span class="line">    gi_sampler = get_generator_input_sampler()</span><br><span class="line">    G = Generator(input_size=g_input_size,</span><br><span class="line">                  hidden_size=g_hidden_size,</span><br><span class="line">                  output_size=g_output_size,</span><br><span class="line">                  f=generator_activation_function)</span><br><span class="line">    D = Discriminator(input_size=d_input_func(d_input_size),</span><br><span class="line">                      hidden_size=d_hidden_size,</span><br><span class="line">                      output_size=d_output_size,</span><br><span class="line">                      f=discriminator_activation_function)</span><br><span class="line">    criterion = nn.BCELoss()  <span class="comment"># Binary cross entropy: http://pytorch.org/docs/nn.html#bceloss</span></span><br><span class="line">    d_optimizer = optim.SGD(D.parameters(), lr=d_learning_rate, momentum=sgd_momentum)</span><br><span class="line">    g_optimizer = optim.SGD(G.parameters(), lr=g_learning_rate, momentum=sgd_momentum)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> d_index <span class="keyword">in</span> range(d_steps):</span><br><span class="line">            <span class="comment"># 1. Train D on real+fake</span></span><br><span class="line">            D.zero_grad()</span><br><span class="line"></span><br><span class="line">            <span class="comment">#  1A: Train D on real</span></span><br><span class="line">            d_real_data = torch.Tensor(d_sampler(d_input_size)) <span class="comment"># 从均值为4，标准差为1.25的正态分布中抽样500个样本作为real data</span></span><br><span class="line">            d_real_decision = D(preprocess(d_real_data)) <span class="comment"># 将该数据的均值，方差，偏度，峰度作为鉴别器输入</span></span><br><span class="line">            d_real_error = criterion(d_real_decision, torch.Tensor(torch.ones([<span class="number">1</span>,<span class="number">1</span>])))  <span class="comment"># ones = true</span></span><br><span class="line">            d_real_error.backward() <span class="comment"># compute/store gradients, but don't change params</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#  1B: Train D on fake</span></span><br><span class="line">            d_gen_input = torch.Tensor(gi_sampler(minibatch_size, g_input_size))</span><br><span class="line">            d_fake_data = G(d_gen_input).detach()  <span class="comment"># detach to avoid training G on these labels</span></span><br><span class="line">            d_fake_decision = D(preprocess(d_fake_data.t()))</span><br><span class="line">            d_fake_error = criterion(d_fake_decision, torch.Tensor(torch.zeros([<span class="number">1</span>,<span class="number">1</span>])))  <span class="comment"># zeros = fake</span></span><br><span class="line">            d_fake_error.backward()</span><br><span class="line">            d_optimizer.step()     <span class="comment"># Only optimizes D's parameters; changes based on stored gradients from backward()</span></span><br><span class="line"></span><br><span class="line">            dre, dfe = extract(d_real_error)[<span class="number">0</span>], extract(d_fake_error)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> g_index <span class="keyword">in</span> range(g_steps):</span><br><span class="line">            <span class="comment"># 2. Train G on D's response (but DO NOT train D on these labels)</span></span><br><span class="line">            G.zero_grad()</span><br><span class="line"></span><br><span class="line">            gen_input = torch.Tensor(gi_sampler(minibatch_size, g_input_size))</span><br><span class="line">            g_fake_data = G(gen_input)</span><br><span class="line">            dg_fake_decision = D(preprocess(g_fake_data.t()))</span><br><span class="line">            g_error = criterion(dg_fake_decision, torch.Tensor(torch.ones([<span class="number">1</span>,<span class="number">1</span>])))  <span class="comment"># Train G to pretend it's genuine</span></span><br><span class="line"></span><br><span class="line">            g_error.backward()</span><br><span class="line">            g_optimizer.step()  <span class="comment"># Only optimizes G's parameters</span></span><br><span class="line">            ge = extract(g_error)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> epoch % print_interval == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Epoch %s: D (%s real_err, %s fake_err) G (%s err); Real Dist (%s),  Fake Dist (%s) "</span> %</span><br><span class="line">                  (epoch, dre, dfe, ge, stats(extract(d_real_data)), stats(extract(d_fake_data))))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Plotting the generated distribution..."</span>)</span><br><span class="line">    values = extract(g_fake_data)</span><br><span class="line">    mu = np.mean(values)</span><br><span class="line">    sigma = np.std(values)</span><br><span class="line">    print(<span class="string">" Values: %s"</span> % (str(values)))</span><br><span class="line">    n, bins, patches = plt.hist(values, bins=<span class="number">100</span>, normed=<span class="number">1</span>)</span><br><span class="line">    y = norm.pdf(bins, mu, sigma)</span><br><span class="line">    plt.plot(bins, y, <span class="string">'r--'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Value'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'probability'</span>)</span><br><span class="line">    plt.title(<span class="string">r'Histogram of Generated Distribution: $\mu={}$, $\sigma={}$'</span>.format(round(mu,<span class="number">2</span>), round(sigma,<span class="number">2</span>)))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train()</span><br></pre></td></tr></tbody></table></figure><p>好，我们来看看最后训练出来的结果<br><img src="http://q96n545no.bkt.clouddn.com/Fqwoici1y6APYM7vvfjJJ5YatVrM" alt=""><br>可以看到，我们预先设置好的正态分布$\mu=4, \sigma=1.25$，通过GAN训练之后，生成器$G$从均匀分布中生成了$\mu=3.9, \sigma=1.24$的正态分布，这已经非常逼近真实分布$p_{data}(x)=N(4, 1.25)$。</p><p>第一篇GAN记录就写到这里，下次学习了将GAN用于半监督学习之后再写。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Deep learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nerual network, PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解python中的装饰器</title>
      <link href="/2020/04/28/python_decorator/"/>
      <url>/2020/04/28/python_decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写过一段时间的python代码或者阅读过python程序的人一定不会陌生“装饰器”，其语法糖为@。今天就来好好看看到底什么是python装饰器，它到底装饰了什么？以及为什么要使用装饰器。</p><h1 id="“装饰器”"><a href="#“装饰器”" class="headerlink" title="“装饰器”"></a>“装饰器”</h1><h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><p>python装饰器是的本质也是函数或者类，它接受另外的函数的作为其逻辑参数，将真正的业务函数包裹在其中。在不影响业务函数执行情况下，对业务函数添加额外的功能。</p><h2 id="为什么要用装饰器"><a href="#为什么要用装饰器" class="headerlink" title="为什么要用装饰器"></a>为什么要用装饰器</h2><p>在前面已经说过，装饰器的作用是在不影响业务函数执行情况下， 对业务函数添加额外的功能。例如，需要打印函数的执行日志，一种方法是在业务函数中添加打印日志语句；但是，当函数数量很多时，这种方法就显得不那么靠谱，而且程序中会充斥着大量的重复代码，影响程序的可读性。这时，装饰器就能够发挥很大的作用。</p><a id="more"></a><h1 id="详解装饰器"><a href="#详解装饰器" class="headerlink" title="详解装饰器"></a>详解装饰器</h1><p>装饰器总的来说分为函数装饰和类装饰器，函数装饰器中又有无参数装饰器和带参数装饰器，所装饰函数也包括无参函数，一个参数或者多个参数函数，甚至是参数个数不固定的函数，以及带有关键字参数的函数。虽然这里说明了装饰的种类比较多，但是其思想完全一样。所以弄懂装饰器工作原理，这些问题也就迎刃而解了。</p><h2 id="无参函数的装饰器"><a href="#无参函数的装饰器" class="headerlink" title="无参函数的装饰器"></a>无参函数的装饰器</h2><p>无参函数的装饰器也即是所装饰函数不带有参数，具体看下面代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无参数函数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, 我是一个业务函数'</span>)</span><br><span class="line"></span><br><span class="line">func = record_logging(func)</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">hello,我是一个业务函数</span><br></pre></td></tr></tbody></table></figure><p>上面的代码实现了一个简单的装饰器，在业务函数执行之前打印正在即将执行函数名称。可以看到真正的业务函数是<code>func()</code>，其被包裹在函数<code>wrapper</code>之中。函数<code>record_logging</code>即是装饰器，它的返回值是一个函数<code>wrapper</code>，然后语句<code>func = record_logging(func)</code>在调用装饰器。这样就能够达到我们所需要的目的。在python中，使用@来告诉python，该函数需要被装饰器所装饰，这样就可以省略掉赋值语句<code>func = record_logging(func)</code>，具体如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'this function is func()'</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">hello,我是一个业务函数</span><br></pre></td></tr></tbody></table></figure><p>可以看出，其执行结果与赋值调用装饰器结果一样。而且使用@使代码更加简洁美观易读，也更加的pythonic。</p><h2 id="一个参数函数的装饰器"><a href="#一个参数函数的装饰器" class="headerlink" title="一个参数函数的装饰器"></a>一个参数函数的装饰器</h2><p>当所装饰的业务函数带有逻辑参数时，又该如何实现装饰器呢？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个参数函数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(name)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running...'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(name)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Printing parameter '{}' is my task"</span>.format(name))</span><br><span class="line"></span><br><span class="line">func(<span class="string">'Chai'</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">Printing parameter 'Love' is my task</span><br></pre></td></tr></tbody></table></figure><p>其逻辑思想与无参数函数装饰器一致，其区别仅仅在于<code>wrapper</code>函数接受业务函数参数（仔细对比无参数函数装饰器的写法）。</p><h2 id="多个参数甚至不固定参数个数函数的装饰器"><a href="#多个参数甚至不固定参数个数函数的装饰器" class="headerlink" title="多个参数甚至不固定参数个数函数的装饰器"></a>多个参数甚至不固定参数个数函数的装饰器</h2><p>这个时候我们就需要用到<code>*args</code>来代替业务函数的逻辑参数。具体使用如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running...'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">"my name is {0}, and my age is {1}"</span>.format(name, age))</span><br><span class="line"></span><br><span class="line">func(<span class="string">'CL'</span>, <span class="number">22</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">my name is CL, and my age is 22</span><br></pre></td></tr></tbody></table></figure><p>当业务函数参数较多或不固定时，只需要将函数<code>wrapper</code>的参数设置为<code>*args</code>即可。当业务函数中包含关键字参数如<code>None</code>时，设置函数<code>wrapper</code>接收<code>**kwargs</code>即可。</p><h2 id="装饰器带有参数"><a href="#装饰器带有参数" class="headerlink" title="装饰器带有参数"></a>装饰器带有参数</h2><p>带有参数的装饰器灵活度更高，其相当于与将装饰器再封装了成函数。例如，在查询函数执行日志时，不同的ID有不同的查询权限，具体如下的例子：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#带参数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_loggings</span><span class="params">(ID)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> ID==<span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'权限太低，没法儿查询'</span>)</span><br><span class="line">            <span class="keyword">elif</span> ID==<span class="number">1</span>:</span><br><span class="line">                print(<span class="string">'请稍后，正在查询...'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_loggings(ID=0)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"虽然我是一个没有参数的业务函数,但是我还是占用了*args,**kwargs哦。"</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">权限太低，没法儿查询</span><br><span class="line">虽然我是一个没有参数的业务函数,但是我还是占用了*args,**kwargs哦。</span><br></pre></td></tr></tbody></table></figure><p>函数装饰器就介绍完了。前面我们说过还有一种装饰器是类装饰器，它是通过类的<code>__call__</code>函数实现的，其具体见如下代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        print(<span class="string">'A class decorator is running...'</span>)</span><br><span class="line">        self.func(name, age)</span><br><span class="line">        print(<span class="string">'The class decorator ended...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">'my name is {0}, and my age is {1}'</span>.format(name, age))</span><br><span class="line"></span><br><span class="line">func(<span class="string">"CL"</span>, <span class="number">22</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A class decorator is running...</span><br><span class="line">my name is CL, and my age is 22</span><br><span class="line">The class decorator ended...</span><br></pre></td></tr></tbody></table></figure><p>这是一个简单的类装饰器，可以看到装饰器的本质还是体现在函数<code>__call__</code>上面（包括参数的传递等），可仔细体会其与函数装饰器之间的异同。</p><h1 id="python中内置装饰器"><a href="#python中内置装饰器" class="headerlink" title="python中内置装饰器"></a>python中内置装饰器</h1><p>在python中常见的内置装饰器有</p><ul><li>@property 把方法变成属性调用</li><li>@staticmethod 静态方法，用来修饰类中的方法，可以使类方法像字段属性一样调用。</li><li>@classmethod 类方法，与@staticmethod类似，@classmethod需要将class传入被修饰的方法中。</li></ul><p>具体的使用方法可以查看官方文档。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文仔细梳理了python中的装饰器工作原理，以及不同装饰器的实现方法，简单介绍了类装饰器。本文作为python装饰器学习之后的一个笔记，记录在此，以备后查！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python,python装饰器@ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
