<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何理解python中的装饰器</title>
      <link href="/2020/04/28/python_decorator/"/>
      <url>/2020/04/28/python_decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写过一段时间的python代码或者阅读过python程序的人一定不会陌生“装饰器”，其语法糖为@。今天就来好好看看到底什么是python装饰器，它到底装饰了什么？以及为什么要使用装饰器。</p><h1 id="“装饰器”"><a href="#“装饰器”" class="headerlink" title="“装饰器”"></a>“装饰器”</h1><h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><p>python装饰器是的本质也是函数或者类，它接受另外的函数的作为其逻辑参数，将真正的业务函数包裹在其中。在不影响业务函数执行情况下，对业务函数添加额外的功能。</p><h2 id="为什么要用装饰器"><a href="#为什么要用装饰器" class="headerlink" title="为什么要用装饰器"></a>为什么要用装饰器</h2><p>在前面已经说过，装饰器的作用是在不影响业务函数执行情况下， 对业务函数添加额外的功能。例如，需要打印函数的执行日志，一种方法是在业务函数中添加打印日志语句；但是，当函数数量很多时，这种方法就显得不那么靠谱，而且程序中会充斥着大量的重复代码，影响程序的可读性。这时，装饰器就能够发挥很大的作用。</p><a id="more"></a><h1 id="详解装饰器"><a href="#详解装饰器" class="headerlink" title="详解装饰器"></a>详解装饰器</h1><p>装饰器总的来说分为函数装饰和类装饰器，函数装饰器中又有无参数装饰器和带参数装饰器，所装饰函数也包括无参函数，一个参数或者多个参数函数，甚至是参数个数不固定的函数，以及带有关键字参数的函数。虽然这里说明了装饰的种类比较多，但是其思想完全一样。所以弄懂装饰器工作原理，这些问题也就迎刃而解了。</p><h2 id="无参函数的装饰器"><a href="#无参函数的装饰器" class="headerlink" title="无参函数的装饰器"></a>无参函数的装饰器</h2><p>无参函数的装饰器也即是所装饰函数不带有参数，具体看下面代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无参数函数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, 我是一个业务函数'</span>)</span><br><span class="line"></span><br><span class="line">func = record_logging(func)</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">hello,我是一个业务函数</span><br></pre></td></tr></tbody></table></figure><p>上面的代码实现了一个简单的装饰器，在业务函数执行之前打印正在即将执行函数名称。可以看到真正的业务函数是<code>func()</code>，其被包裹在函数<code>wrapper</code>之中。函数<code>record_logging</code>即是装饰器，它的返回值是一个函数<code>wrapper</code>，然后语句<code>func = record_logging(func)</code>在调用装饰器。这样就能够达到我们所需要的目的。在python中，使用@来告诉python，该函数需要被装饰器所装饰，这样就可以省略掉赋值语句<code>func = record_logging(func)</code>，具体如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'this function is func()'</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">hello,我是一个业务函数</span><br></pre></td></tr></tbody></table></figure><p>可以看出，其执行结果与赋值调用装饰器结果一样。而且使用@使代码更加简洁美观易读，也更加的pythonic。</p><h2 id="一个参数函数的装饰器"><a href="#一个参数函数的装饰器" class="headerlink" title="一个参数函数的装饰器"></a>一个参数函数的装饰器</h2><p>当所装饰的业务函数带有逻辑参数时，又该如何实现装饰器呢？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个参数函数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(name)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running...'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(name)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Printing parameter '{}' is my task"</span>.format(name))</span><br><span class="line"></span><br><span class="line">func(<span class="string">'Chai'</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">Printing parameter 'Love' is my task</span><br></pre></td></tr></tbody></table></figure><p>其逻辑思想与无参数函数装饰器一致，其区别仅仅在于<code>wrapper</code>函数接受业务函数参数（仔细对比无参数函数装饰器的写法）。</p><h2 id="多个参数甚至不固定参数个数函数的装饰器"><a href="#多个参数甚至不固定参数个数函数的装饰器" class="headerlink" title="多个参数甚至不固定参数个数函数的装饰器"></a>多个参数甚至不固定参数个数函数的装饰器</h2><p>这个时候我们就需要用到<code>*args</code>来代替业务函数的逻辑参数。具体使用如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is running...'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">"my name is {0}, and my age is {1}"</span>.format(name, age))</span><br><span class="line"></span><br><span class="line">func(<span class="string">'CL'</span>, <span class="number">22</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func is running...</span><br><span class="line">my name is CL, and my age is 22</span><br></pre></td></tr></tbody></table></figure><p>当业务函数参数较多或不固定时，只需要将函数<code>wrapper</code>的参数设置为<code>*args</code>即可。当业务函数中包含关键字参数如<code>None</code>时，设置函数<code>wrapper</code>接收<code>**kwargs</code>即可。</p><h2 id="装饰器带有参数"><a href="#装饰器带有参数" class="headerlink" title="装饰器带有参数"></a>装饰器带有参数</h2><p>带有参数的装饰器灵活度更高，其相当于与将装饰器再封装了成函数。例如，在查询函数执行日志时，不同的ID有不同的查询权限，具体如下的例子：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#带参数的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_loggings</span><span class="params">(ID)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> ID==<span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'权限太低，没法儿查询'</span>)</span><br><span class="line">            <span class="keyword">elif</span> ID==<span class="number">1</span>:</span><br><span class="line">                print(<span class="string">'请稍后，正在查询...'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_loggings(ID=0)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"虽然我是一个没有参数的业务函数,但是我还是占用了*args,**kwargs哦。"</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">权限太低，没法儿查询</span><br><span class="line">虽然我是一个没有参数的业务函数,但是我还是占用了*args,**kwargs哦。</span><br></pre></td></tr></tbody></table></figure><p>函数装饰器就介绍完了。前面我们说过还有一种装饰器是类装饰器，它是通过类的<code>__call__</code>函数实现的，其具体见如下代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        print(<span class="string">'A class decorator is running...'</span>)</span><br><span class="line">        self.func(name, age)</span><br><span class="line">        print(<span class="string">'The class decorator ended...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">'my name is {0}, and my age is {1}'</span>.format(name, age))</span><br><span class="line"></span><br><span class="line">func(<span class="string">"CL"</span>, <span class="number">22</span>)</span><br></pre></td></tr></tbody></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A class decorator is running...</span><br><span class="line">my name is CL, and my age is 22</span><br><span class="line">The class decorator ended...</span><br></pre></td></tr></tbody></table></figure><p>这是一个简单的类装饰器，可以看到装饰器的本质还是体现在函数<code>__call__</code>上面（包括参数的传递等），可仔细体会其与函数装饰器之间的异同。</p><h1 id="python中内置装饰器"><a href="#python中内置装饰器" class="headerlink" title="python中内置装饰器"></a>python中内置装饰器</h1><p>在python中常见的内置装饰器有</p><ul><li>@property 把方法变成属性调用</li><li>@staticmethod 静态方法，用来修饰类中的方法，可以使类方法像字段属性一样调用。</li><li>@classmethod 类方法，与@staticmethod类似，@classmethod需要将class传入被修饰的方法中。</li></ul><p>具体的使用方法可以查看官方文档。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文仔细梳理了python中的装饰器工作原理，以及不同装饰器的实现方法，简单介绍了类装饰器。本文作为python装饰器学习之后的一个笔记，记录在此，以备后查！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python,python装饰器@ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+hexo搭建个人博客全过程</title>
      <link href="/2020/04/23/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/04/23/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们用github和hexo博客框架来搭建一个属于自己的个人博客。纯新手小白入，在搭建的过程中，我会详细整理步骤，每一步中应该注意的事项。生命不息，折腾不止。let’s go!</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在开始整个的博客搭建之前，我们要先准备好需要用到的东西。</p><ol><li>github账号一个</li><li>安装博客框架hexo</li></ol><a id="more"></a><h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><p>首先就是github账号，这个到<a href="https://github.com/" target="_blank" rel="noopener">官网</a>注册一个就好啦。然后新建一个仓库，仓库名称有固定的写法：<strong>用户名</strong>.github.io。这里的“用户名”指的是你注册GitHub账号时的用户名。</p><center><img src="http://q96n545no.bkt.clouddn.com/FhJr2DiIphjhdUjcNQSoPfCsTq32" ,width="50%" ,="" height="30%">Fig 1. 新建仓库"**用户名**.github.io"</center><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>Ok,现在解决第二个东东，安装hexo,这个也是整个过程中稍显复杂的一步。因为要安装它还要先安装另外两个小东西。按照步骤一步一步来，也没有什么麻烦的。我们首先需要安装git,这个东西是一个开源的分布式版本控制系统，想了解更多的小伙伴可以查看廖雪峰老师的<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a>：。我们这里为什么要安装它，因为我们在本地搭建好博客之后，需要用它跟我们的GitHub同步。现在从<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网</a>选择适合自己电脑的版本下载安装。安装完成之后可以从命令行中输入git查看是否安装成功。</p><center><img src="http://q96n545no.bkt.clouddn.com/Fq0v3r1hGjobVLz54x7jyMDLaVam">fig 2. 查看git是否安装成功</center><p>成功安装之后，我们需要将git于github这两兄弟绑在一起。在菜单栏里面搜索<code>Git Bash</code>，配置user.name和user.email信息，如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 这里填你的GitHub用户名</span><br><span class="line">git config --global user.name 这里填你的GitHub注册邮箱</span><br></pre></td></tr></tbody></table></figure><p>现在就需要生成密钥文件啦，用来将git和GitHub对应起来。<br>再输入</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 这里填你的GitHub注册邮箱</span><br></pre></td></tr></tbody></table></figure><p>一路回车整起来，然后找到密钥文件，一般是在用户文件夹下的.ssh文件夹里面的”id_rsa.pub”，打开并全部复制，打开<a href="https://github.com/settings/keys" target="_blank" rel="noopener">页面</a>,新建一个SSH key。设置过程中，title字段随意，Key字段粘贴刚才复制的内容，Add SSH key。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>现在就该安装第二个小东西了Node.js。因为hexo是基于Node.js的，所以我们需要<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">下载</a>安装它，可在命令行中输入<code>node -v</code>查看是否安装成功。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>到了这里终于可以安装主角hexo了。我们现在自己电脑上新建一个文件夹hexo_blog，然后在该hexo_blog中打开命令行，使用npm安装hexo(忘了说了，这个npm在安装Node.js时就一起安装好了的)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure><p>安装完成之后呢，我们还是在这个目录下初始化博客，用下面的命令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></tbody></table></figure><p>到这里为止，一个博客雏形就有了哦，是不时特别期待瞧瞧自己的博客<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8">😎</span><br>在文件夹blog下打开命令行，输入如下三条命令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new test</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>在浏览器中输入localhost:4000就可以查看搭建好的博客啦<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8">👊</span></p><p>走到这里，我们就已经基本搭建好了我们的个人博客。但是呢，这样的博客还是比较简陋的，所以我们还得继续折腾，let’s go。咳咳，先解释下上面三条命令，分别是新建一篇博客，生成博客，本地预览，哦了。现在我们得把它从本地部署到github上面。开始下面工作的之前，先说明两个文件哈的称谓，为了我们后面方便叙述。<br><strong>站点配置文件</strong> blog文件夹下面的_config.yml<br><strong>主题配置文件</strong> blog文件夹下的theme文件夹下的_config.yml<br>下面设置将本地文件部署到github，打开站点配置文件，添加如下内容，需要注意的是这个有缩进的(这个可以参考下文件里面的其他地方写法)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repo: https://github.com/用户名/用户名.github.io.git</span><br><span class="line"> branch: master</span><br></pre></td></tr></tbody></table></figure><p>最后安装要给一个git部署插件(在blog文件夹下)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><p>现在就可以用如下命令部署自己的博文啦</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></tbody></table></figure><p>大功告成！现在就可以在浏览器中输入<code>用户名.github.io</code>，就可以在网络上访问我们自己的博客了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>后面基本上就是对博客的一些优化了，比如更换主题啊，美化博客呀这些。这些就比较简单啦，网上也有很多很好的教程给大家参考。哦了。就写到这些里吧。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">emoji使用</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 有用的小仓库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写在开始</title>
      <link href="/2020/04/23/hello-world/"/>
      <url>/2020/04/23/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>经过大概两三天的样子的折腾，第一个个人博客终于是搭建好了！搭建过程中遇到了很多问题，可总也摸索着解决掉了，现在一个可简单使用的个人博客就这么捣鼓成了。面对一个被自己创造出来的东西，人们总是很欣喜的，而我也不例外。<a id="more"></a>总要在它诞生之初说点什么，好像是对它的尊重，也好像是对自己的尊重，也更像是一种仪式。就像一个刚出生的婴儿，落地之时的哇哇哭声，新手程序员的 “hello world”。恰好，这段文字就是诞生之日的一点声音，一句问候 “hello world”。</p><center><img src="http://q96n545no.bkt.clouddn.com/FquUVYSyHbEqjzc36xfy9SF3OIh3"></center><h2 id="唠吧"><a href="#唠吧" class="headerlink" title="唠吧"></a>唠吧</h2><p>感觉好多话想说说，可是一到要写成文字的时候，却又不知道该说些什么了好。老早的时候就想搭建一个自己的个人博客，可是由于种种的原因，一直没有付诸到行动中上，就拖沓至今了。幸好利用这段稍显空闲的时间，也是完成了之前的一个愿想吧，终于心满意足。窗外淅淅沥沥的下着小雨，播放器里传出周董的 ‘<a href="https://y.qq.com/portal/search.html#page=1&amp;searchid=1&amp;remoteplace=txt.yqq.top&amp;t=song&amp;w=%E7%AE%80%E5%8D%95%E7%88%B1" target="_blank" rel="noopener">河边的风 在吹着头发 飘动</a>‘, 伏在案前一边查资料搭建博客，一边偶尔解决她的各种各样小问题(虽然有时解决的不是很完美吧，可是我也是很认真的在思考解决了的哦<img src="http://www.webpagefx.com/tools/emoji-cheat-sheet/graphics/emojis/bowtie.png" height="20" width="20" align="absmiddle">)。一直在想，以后要在这上面记录一些什么东西呢，生活？学习？或者是读过的书，看过的电影，又或者是一些想法，一些感悟？嗯，都有可能吧，反正现在还没确定好它的主要作用，暂且就当作我的一个记事本吧。想到什么就写些什么<img src="http://www.webpagefx.com/tools/emoji-cheat-sheet/graphics/emojis/sunglasses.png" height="20" width="20" align="absmiddle">，这样也就不会太过于纠结，写起来会更轻松惬意一些。希望以后自己能坚持下来，多写一些东西，多思多想。</p><h2 id="该收尾啦"><a href="#该收尾啦" class="headerlink" title="该收尾啦"></a>该收尾啦</h2><p>既然决定了开始一件事儿，所以，就来吧。我还是喜欢”来日方长”这个词儿，这不代表我不就珍惜当下。诸君来日方长。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情， 感悟，文字 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
